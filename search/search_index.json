{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pyparam","title":"pyparam","text":"<p>Powerful parameter processing</p> <p>[!Warning] This package is deprecated. Please use argx instead.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Command line argument parser (with subcommand support)</li> <li>Rich type support, including <code>py</code>, <code>json</code>, <code>namespace</code>, etc.</li> <li>Type overwriting for parameters from command line</li> <li>Arbitrary parsing arguments from command line</li> <li>Automatic help page assembling</li> <li>Help page customization</li> <li>Callbacks for option values</li> <li>Parameter loading from configuration files</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U pyparam\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>https://pwwang.github.io/pyparam/</p>"},{"location":"#basic-usage","title":"Basic usage","text":"<p><code>example.py</code></p> <pre><code>from rich import print\nfrom pyparam import Params\n# program name, otherwise sys.argv[0]\nparams = Params(prog='pyparam', desc=\"An example for %(prog)s\")\n# adding parameters\nparams.add_param('i, int', type=int,\n                 desc=\"An integer argument.\")\nparams.add_param('float', default=0.1, # type float implied\n                 desc=\"A float argument.\")\nparams.add_param('str', type=str,\n                 desc=\"A str argument.\")\nparams.add_param('flag', type=bool,\n                 desc=\"A flag argument.\")\nparams.add_param('c,count', type='count',\n                 desc=\"A count argument.\")\nparams.add_param('a', type='auto', type_frozen=False,\n                 desc=\"Value will be automatically casted.\")\nparams.add_param('py', type='py',\n                 desc=\"Value will be evaluated by `ast.literal_eval`.\")\nparams.add_param('json', type='json',\n                 desc=\"Value will be converted using `json.loads`.\")\nparams.add_param('list', type='list',\n                 desc=\"Values will be accumulated.\")\nparams.add_param('path', type='path', required=True,\n                 desc=\"Value will be casted into `pathlib.Path`.\",\n                 callback=( # check if path exists\n                     lambda path: ValueError('File does not exist.')\n                     if not path.exists() else path\n                 ))\nparams.add_param('choice', type='choice', default='medium',\n                 choices=['small', 'medium', 'large'],\n                 desc=\"One of {choices}.\")\nparams.add_param('config.ncores', default=1, # namespace config implied\n                 argname_shorten=False,\n                 desc='Number of cores to use.')\n\nprint(vars(params.parse()))\n</code></pre> <p>Try it out:</p> <pre><code>python example.py\n</code></pre> <p></p> <pre><code>$ python example.py \\\n    -i2 \\\n    --float 0.5 \\\n    --str abc \\\n    -ccc \\\n    -a:int 1 \\\n    --py \"{1,2,3}\" \\\n    --json \"{\\\"a\\\": 1}\" \\\n    --list 1 2 3 \\\n    --choice large \\\n    --path . \\\n    --config.ncores 4\n</code></pre> <pre><code>{\n    'i': 2,\n    'int': 2,\n    'float': 0.5,\n    'str': 'abc',\n    'flag': False,\n    'c': 3,\n    'count': 3,\n    'a': 1,\n    'py': {1, 2, 3},\n    'json': {'a': 1},\n    'list': [1, 2, 3],\n    'path': PosixPath('.'),\n    'choice': 'large',\n    'config': Namespace(ncores=4)\n}\n</code></pre> <p>Try more features with:</p> <pre><code>python -m pyparam\n</code></pre>"},{"location":"#shell-completions","title":"Shell completions","text":"<p>Here is how the command completion in <code>fish</code> works:</p> <p></p> <p>Check the documentation, as well as the <code>__main__.py</code> to see how the completion works.</p>"},{"location":"CHANGELOG/","title":"CHANGELOG","text":""},{"location":"CHANGELOG/#change-log","title":"Change Log","text":""},{"location":"CHANGELOG/#054","title":"0.5.4","text":"<ul> <li>\u2b06\ufe0f Upgrade rich to ^13</li> <li>\ud83d\udc77 Use latest actions for CI</li> <li>\ud83d\udcdd Update gh action badges in README.md</li> </ul>"},{"location":"CHANGELOG/#053","title":"0.5.3","text":"<ul> <li>\ud83d\udca5 Use \"%\" to format description and usage.</li> </ul>"},{"location":"CHANGELOG/#052","title":"0.5.2","text":"<ul> <li>\ud83e\ude79 Fix newline lost of section title in help (Textualize/rich#2274)</li> </ul>"},{"location":"CHANGELOG/#051","title":"0.5.1","text":"<ul> <li>\ud83d\udcc4 Add license</li> </ul>"},{"location":"CHANGELOG/#050","title":"0.5.0","text":"<ul> <li>\u2b06\ufe0f Upgrade python-simpleconf to v0.5</li> <li>\ud83d\udc77 Remove python3.6 and add python3.10 in CI</li> </ul>"},{"location":"CHANGELOG/#0417","title":"0.4.17","text":"<ul> <li>\ud83d\udc7d\ufe0f Adopt rich 11+</li> </ul>"},{"location":"CHANGELOG/#0416","title":"0.4.16","text":"<ul> <li>\ud83e\ude79 Fix description formatting exception not captured</li> </ul>"},{"location":"CHANGELOG/#0415","title":"0.4.15","text":"<ul> <li>\ud83d\udc1b Allow namespace parameter to be defined in express way from a file</li> </ul>"},{"location":"CHANGELOG/#0414","title":"0.4.14","text":"<ul> <li>\ud83d\udc1b Allow json params to be defined from file</li> <li>\u2728 Add <code>--full</code> to show full list of options on help page</li> </ul>"},{"location":"CHANGELOG/#0413","title":"0.4.13","text":"<ul> <li>\ud83e\ude79 Fix non-str object being casted to json</li> </ul>"},{"location":"CHANGELOG/#0412","title":"0.4.12","text":"<ul> <li>\ud83e\ude79 Allow ParamJson to have python object values, not only strings</li> </ul>"},{"location":"CHANGELOG/#0411","title":"0.4.11","text":"<ul> <li>\ud83d\udc1bFix the same param not allowed to add</li> </ul>"},{"location":"CHANGELOG/#0410","title":"0.4.10","text":"<ul> <li>\u2728Add _to_dict for parsed Namespace object</li> </ul>"},{"location":"CHANGELOG/#048","title":"0.4.8","text":"<ul> <li>Add kwargs to <code>to</code> and <code>copy</code> for Param</li> </ul>"},{"location":"CHANGELOG/#047","title":"0.4.7","text":"<ul> <li>Use basename in help for prog name by default</li> <li>Fix ignore_errors not ignoring the non-PyParamException errors</li> </ul>"},{"location":"CHANGELOG/#046","title":"0.4.6","text":"<ul> <li>Make sure switching # arugments of callbacks correctly</li> <li>Only print errors with help for callbaks to return exceptions, otherwise, raise them</li> <li>Make clean logger level name</li> </ul>"},{"location":"CHANGELOG/#045","title":"0.4.5","text":"<ul> <li>Change help_cmd to choice</li> </ul> <p>-</p>"},{"location":"CHANGELOG/#044","title":"0.4.4","text":"<ul> <li>Don't use shared console for logging</li> <li>Allow command to be not provided.</li> </ul>"},{"location":"CHANGELOG/#043","title":"0.4.3","text":"<ul> <li>Allow default value of other types to be None</li> <li>Fix None value conversion at runtime</li> </ul>"},{"location":"CHANGELOG/#042","title":"0.4.2","text":"<ul> <li>Don't use <code>hasattr</code> for <code>__contains__</code> for Namespace, which allows override of <code>__getattr__</code></li> <li>Move help_modifier to params construct</li> <li>Update HelpAssembler when command is reused.</li> <li>Allow completions for show=True only parameters</li> <li>Add kwargs of params to to_dict</li> <li>Fix fish completion shell code</li> <li>Fix prog update for Params</li> <li>Separate defaults of params and param to save size of dumped dict/file</li> <li>Add update (<code>__or__</code>, <code>__ior__</code>) for namespace</li> <li>Fix positional/command next to bool from cli</li> <li>Fix decendents of ns parameter are hidden from completions if the ns parameter is hidden.</li> </ul>"},{"location":"CHANGELOG/#041","title":"0.4.1","text":"<ul> <li>Add help_modifier argument for <code>params.parse</code> to modify help parameters and commands</li> <li>Add <code>params.to_file</code> to dump <code>params</code></li> <li>Allow command reuse</li> <li>Add <code>force</code> for <code>params.from_file</code>, <code>params.from_dict</code> to force adding parameters and commands</li> </ul>"},{"location":"CHANGELOG/#040","title":"0.4.0","text":"<ul> <li>Allow parameter reuse</li> <li>Add shell completions support</li> <li>Add dir parameter type. It is not different as path parameter, but it show different complete candidate for shell completions.</li> </ul>"},{"location":"CHANGELOG/#032","title":"0.3.2","text":"<ul> <li>Fix required list parameter not raise error when on value provided</li> </ul>"},{"location":"CHANGELOG/#031","title":"0.3.1","text":"<ul> <li>Add default to from_arg</li> </ul>"},{"location":"CHANGELOG/#030","title":"0.3.0","text":"<ul> <li>Remodel the package with better APIs.</li> </ul>"},{"location":"TypesOfParams/","title":"Defining parameters","text":"<p>A parameter is supposed to be defined/added by <code>params.add_param(...)</code> or <code>command.add_param(...)</code>, where <code>command</code> is the command added by <code>params.add_command(...)</code>.</p>"},{"location":"TypesOfParams/#parameter-names","title":"Parameter names","text":"<p>We are not distinguishing name and its aliases for a parameter. That means basically all names for a parameter are treated equally. The only difference is the order when they are displayed in the help page, where they are sorted by their length.</p> <p>Supposingly, when add a parameter, any given name should not be registered before. Meaning that there should not be any parameters or commands with any of the given names added before.</p> <p>Note</p> <p>Why a name should not be shared by a parameter and a command?</p> <p>That's because the parsed results are stored in a <code>Namespace</code>. You can't tell whether <code>ns.abc</code> is to get the value of the parameter <code>abc</code> or the values of parameters that are under command <code>abc</code>.</p> <p>However, you can overwrite existing parameters or commands by <code>params.add_param(..., force=True)</code>. By doing this, you should know what you will lose.</p>"},{"location":"TypesOfParams/#parameter-types","title":"Parameter types","text":"<p>You can specify a type explictly by <code>params.add_param(..., type='int')</code>, or if you provide a default value for the parameter, the type will be automatically inferred from the default value:</p> Example of default value Parameter type inferred <code>1</code> int <code>1.1</code>, <code>5e-2</code> float <code>\"foo\"</code> str <code>True</code>, <code>False</code> bool <code>pathlib.Path('.')</code> path <code>{\"foo\": \"bar\"}</code> json <code>[1, 2, 3]</code> list:int <code>[\"foo\", \"bar\", 1]</code> list otherwise auto <p>For <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code> and <code>list</code>, you can specify the type using the type itself instead of its name. For example, you can do <code>params.add_param('foo', type=int)</code> instead of <code>params.add_param('foo', type='int')</code>.</p>"},{"location":"TypesOfParams/#intfloatstr-paramter","title":"int/float/str paramter","text":"<p>Alias: <code>i/f/s</code>. Default value if not specified: <code>0/0.0/\"\"</code></p> <p>Values passed in will be casted into corresponding types.</p>"},{"location":"TypesOfParams/#auto-paramter","title":"auto paramter","text":"<p>Alias: <code>a</code>. Default value if not specified: <code>None</code></p> <p>Values will be casted automatically according to the values.</p> <p>For example:</p> Value (str) Casted value <code>\"True\"</code>, <code>\"TRUE\"</code>, <code>\"true\"</code> <code>True</code> <code>\"False\"</code>, <code>\"FALSE\"</code>, <code>\"false\"</code> <code>False</code> <code>\"1\"</code> <code>1</code> <code>\"0.05\"</code>, <code>\"5e-2\"</code> <code>0.05</code> <code>\"{\\\"foo\\\": \\\"bar\\\"}\"</code> <code>{\"foo\": \"bar\"}</code>"},{"location":"TypesOfParams/#bool-paramter","title":"bool paramter","text":"<p>Alias: <code>b/flag</code> Default value if not specified: <code>False</code></p> <p>Similar as <code>int/float/str</code> parameters. The difference is that, when it is followed by a value that can be casted into a bool value, it consumes it. Otherwise, it doesn't. For example, following will be parsed into the same result:</p> <pre><code>$ prog -b\n$ prog -b true\n</code></pre>"},{"location":"TypesOfParams/#count-paramter","title":"count paramter","text":"<p>No alias. Default value if not specified: <code>0</code></p> <p>A count parameter is actually an int parameter, with a short name with length = 1 required (say <code>v</code>). So that we can do <code>-vvv</code> from the command line.</p> <p>A count parameter requires default value to be <code>0</code>. In the above case, <code>-vvv</code> will be parsed as value <code>3</code>. Users can also use the normal way to pass the value to a count parameter: <code>-v 3</code>, or if it has a long name: <code>--verbose 3</code>.</p> <p>You can also specify a maximum value for the count parameter. For example: <code>params.add_param('v, verbose', type='count', max=3)</code> will raise an error when <code>-vvvv</code> received.</p>"},{"location":"TypesOfParams/#path-parameter","title":"path parameter","text":"<p>Alias: <code>p/file</code> Default value if not specified: <code>None</code></p> <p>THe value of a path parameter will be automatically converted into a <code>pathlib.Path</code> object.</p> <p>Tip</p> <p>It will not check the existence of path by default.</p> <p>To do that, you will need to use callback. For example: <pre><code>def callback(path):\n    if not path.exists():\n        raise ValueError(\"Path does not exist.\")\n    return path\nparams.add_param('input-file',\n                 type='path',\n                 required=True,\n                 callback=callback)\n</code></pre></p> <p>See how callback works at parameter callbacks</p>"},{"location":"TypesOfParams/#dir-parameter","title":"dir parameter","text":"<p>No alias.</p> <p>It is the same as path paramter in terms of parsing and casting the values. However, it is difference in shell completion. It only shows directories, but path parameter will show all available files.</p>"},{"location":"TypesOfParams/#py-paramter","title":"py paramter","text":"<p>No alias. Default value if not specified: <code>None</code></p> <p>The value will be evaluated by <code>ast.literal_eval</code>.</p>"},{"location":"TypesOfParams/#json-paramter","title":"json paramter","text":"<p>Alias: <code>j</code> Default value if not specified: <code>None</code></p> <p>The value will be converted using <code>json.loads</code></p>"},{"location":"TypesOfParams/#choice-paramter","title":"choice paramter","text":"<p>Alias: <code>c</code> Default value if not specified: The first element of <code>choices</code></p> <p>The value is required to be one of the given values. To provide choices to choose:</p> <p><code>params.add_param('choice', choices=[\"small\", \"medium\", \"large\"])</code></p> <p>Default is <code>small</code> if not provided.</p>"},{"location":"TypesOfParams/#list-paramter","title":"list paramter","text":"<p>Aliases: <code>l</code>, <code>array</code> Default value if not specified: <code>[]</code></p> <p>A list parameter keeps consuming the value followed by until it hits another argument in command line. For example: <code>--array 1 2 3</code> will produce <code>[1, 2, 3]</code> for <code>array</code>, while <code>--array 1 --array 2 --array 3</code> does the same.</p> <p>You would like to provide a default value for a list parameter, say <code>[1, 2, 3]</code>. When it receives <code>--array 4</code> from command line, the value will accumulated and become <code>[1, 2, 3, 4]</code>. Sometimes, users may want to start a new array for that parameter, meaning that only <code>[4]</code> is desired by passing <code>--array 4</code>. In such a case, users can do <code>--array:reset 4</code> or <code>--array:r 4</code>. To accumulate more values, they can do <code>--array:r 4 5 6</code> or <code>--array:4 --array 5 --array 6</code>.</p> <p>A list parameter can have a subtype for the element of the list to be casted to. A subtype should be any of the above (scalar) types, not including <code>list</code>. By default, the subtype is <code>auto</code>. You can specify one explictly by: <code>params.add_param('array', type='list:str')</code>, then <code>--array 1 2 3</code> will produce <code>['1', '2', '3']</code> instead of <code>[1, 2, 3]</code>.</p>"},{"location":"TypesOfParams/#namespace-parameter","title":"namespace parameter","text":"<p>Name: <code>ns</code>, alias: <code>namespace</code></p> <p>A namespace parameter is a special parameter that does not consume or receive any values. It only serves as a namesapce for other paramters.</p> <p>A namespace parameter can be defined explictly or implicitly. If you define a parameter like this: <code>params.add_param('config.ncores', ...)</code> then the namespace parameter <code>config</code> is implied. You may also define a namespace parameter explictly: <pre><code>params.add_param('config', type='ns', desc='A collection of configurations')\n</code></pre></p> <p>Warning</p> <p>A namespace parameter should be defined before the parameters under it.</p> <p>If a namespace parameter has aliases, the parameters under it will expand their names in the namespace part with all names of this namespace parameter.</p> <p>For example: <pre><code>params.add_param('c, config', type='ns')\nparam = params.add_param('c.ncores', type=int, desc='Number of cores')\n# param.names == ['c.ncores', 'config.ncores']\n</code></pre></p>"},{"location":"TypesOfParams/#parameter-descriptions","title":"Parameter descriptions","text":"<p>To add descriptions for a parameter: <code>params.add_param(..., desc=...)</code>. Descriptions can be given as a single string or a list of strings. The difference is that, in the help page, the single string will be automatically wrapped according to the given console width; while each element of the list will be ensured to be put in a new line. If each element is beyond the width, it will be wrapped as well.</p> <p>For example, you can't control where it will be wrapped by <code>params.add_param(..., desc='I might be a very very long description')</code>. However, you can break it down and specify it as a list of some short strings: <code>params.add_param(..., desc=['I might be a very ', 'very long description'])</code>. In this way, the description is ensured to be broken between the two <code>very</code>s. If the width is wider than the two strings, they won't be wrapped any more. And they will automatically if the width is narrower.</p> <p>You can also use some placeholders in the description, including the keyword argument from <code>params.add_param(...)</code>. For example: <code>params.add_param('choice', default=1, choices=[1, 2, 3], desc='One of {choices}')</code> will give you <code>One of [1, 2, 3]</code>.</p> <p>You can insert inline code or code blocks in the description.</p> <p>For inline code, they should be quoted by one or more backticks. In most cases, it should be single backtick. However, when you have backtick inside your inline code, you may want to use multiple.</p> <p>For code blocks, you can do <code>python console</code> way:</p> <p><code> &gt;&gt;&gt; print('Hello pyparam!') </code></p> <p>Or the markdown way:</p> <p><code> ```python print('Hello pyparam!') ``` </code></p>"},{"location":"TypesOfParams/#add-default-value-in-description","title":"Add default value in description","text":"<p>Default value is automatically added for optional (<code>required=False</code>) and non-namespace (<code>type!='ns'</code>) parameters. It will be added in the format of <code>Default: xxx</code> and appended to the first element of the description list.</p> <p>For example: <pre><code>params.add_param('i', desc=[\n    'This is an int argument.',\n    'More details about it.'\n])\n</code></pre> will produce:</p> <p><pre><code>This is an int argument. Default: 0\nMore details about it.\n</code></pre> However, a description of a single string will have default value appended to the end.</p> <p>You can also add your own default value to description, by <code>Default: xxx</code> or <code>DEFAULT: xxx</code> to any element of the description list, or the single description string. Once detected, the default value specified by <code>params.add_param(..., default=xxx)</code> will not be added again.</p> <p>This opens oppotunities for you to place and customize the default value shown in help page by yourself.</p> <p>In the above example, if you want to put the default value in a new line rather than append it to the first line: <pre><code>params.add_param('i', desc=[\n    'This is an int argument.',\n    'Default: 0',\n    'More details about it.'\n])\n</code></pre></p> <p>Tip</p> <p>If you have newlines in the default value, the whole default will be put in a new line. And from the second line on, it will be indented.</p> <p>For example: <pre><code>params.add_param('s', default=\"1\\n2\")\n</code></pre> will produce <pre><code>No description.\nDefault: 1\n         2\n</code></pre></p> <p>This is helpful for you to align the default value when you have complex ones.</p>"},{"location":"TypesOfParams/#parameter-callbacks","title":"Parameter callbacks","text":"<p>Parameters, including namespace parameter, can have callbacks to modify their values after parsing. The results from the callbacks can be arbitrary, meaning the value from the result namespace can be in different type as specified.</p> <p>Exceptions can be raised from callbacks, and they will be interpreted as errors in the help page. To allow exceptions in lambda functions, instead of raise, you can also return an <code>Exception</code> object if error happens.</p> <p>Here are some examples to show how callbacks work:</p> <ul> <li> <p>Check if value of path parameter exists</p> <pre><code>def callback(path):\n    if not path.exists():\n        raise ValueError('Path does not exist.')\n    return path\n\nparams.add_param('in-file', type='p', callback=callback)\n# or alternatively\nparams.add_param('in-file', type='p',\n                 callback=lambda path: ValueError('Path does not exist.')\n                 if not path.exists() else path)\n\nparsed = params.parse(['--in-file', '/path/not/exists/'])\n\n# Error:   --in-file: Path does not exist.\n</code></pre> </li> <li> <p>Modify count value</p> <p>Since the default value is required to be <code>0</code>, you may modified the value as you like: <pre><code>params.add_param('v', type='count')\n\nparsed = params.parse('-vvv', callback=lambda val: val * 10)\n# parsed = Namespace(v=30)\n</code></pre></p> </li> <li> <p>Modify a namespace value</p> <p><pre><code>params.add_param('config', type='ns',\n                 callback=lambda val: val.ncores*val.mem)\nparams.add_param('config.ncores', type=int)\nparams.add_param('config.mem', type=int)\n\nparsed = params.parse(['--config.ncores', '4', '--config.mem', '1024000'])\n# parsed.config == 4 * 1024000\n</code></pre> See Using the parsed values for more details on how to use the namespace values attached to a namespace parameter.</p> </li> <li> <p>Modify value using other values</p> <pre><code>params.add_param('pool', type=list, default=['small', 'medium', 'large'])\nparams.add_param('choice', type='c', default=0, choices=[0, 1, 2],\n                 callback=lambda val, allvals: allvals.pool[val])\nparsed = params.parse(['--choice', '1'])\n# parsed.choice == 'medium'\n</code></pre> </li> </ul>"},{"location":"TypesOfParams/#parameter-reuse","title":"Parameter reuse","text":"<p>Parameters can be reused once created. For example: <pre><code>cmd1 = params.add_command('cmd1', help_on_void=False)\ncmd2 = params.add_command('cmd2', help_on_void=False)\ncmd3 = params.add_command('cmd3', help_on_void=False)\nparam1 = cmd1.add_param('i', default=1)\nparam2 = cmd1.add_param('l', default=[1, 2])\nparam3 = cmd1.add_param('c', type='ns')\nparam4 = cmd1.add_param('c.a', default=[8, 9])\ncmd2.add_param(param1)\ncmd2.add_param(param2)\ncmd2.add_param(param3)\ncmd3.add_param(param4)\n</code></pre></p> <p>The first argument of <code>add_param</code> can be a <code>Param</code> object. In such a case, other arguments will be ignored, except <code>force</code> and <code>group</code>.</p> <p>For namespace parameter, if it is reused, all of its decendents will be reused (copied), too. However, for a parameter under a namespace parameter, if it is reused independent, the namespace parameter will not will be copied. Instead, a new namespace will created for it. In the above case, <code>cmd3.params['c']is not param3</code>.</p> <p>You may also use the <code>ParamInt</code>, <code>ParamFloat</code> to initialize a parameter, and reuse them later. For example:</p> <pre><code>from pyparam import Params\nfrom pyparam.param import ParamInt\nparam = ParamInt(['i'], default=1)\n\nparams = Params()\nparams.add_param(param)\nparams.add_command('cmd').add_param(param)\n</code></pre> <p>Note</p> <p>By passing a <code>Param</code> object to <code>add_param</code>, it will be automatically copied. You don't need to do: <pre><code>params.add_param(param.copy())\n</code></pre> Even though, we have <code>param.copy()</code> API public.</p>"},{"location":"TypesOfParams/#help-parameter","title":"Help parameter","text":"<p>Help parameter is defined when a command is defined by passing <code>help_keys</code> to <code>Params(...)</code>. After that, there is no way to modify it. For example, change the group of the help parameter in help page.</p> <p>To do that, you need to define a callback and pass it to <code>params.parse</code>.</p> <p>See Modifying help command</p>"},{"location":"commands/","title":"Commands","text":""},{"location":"commands/#root-command","title":"Root command","text":"<p>Root command is instantiated like <code>params = Params(...)</code>, and sub-commands are added like <code>params.add_command(...)</code>. Both root command and sub-commands are objects of class <code>Params</code>.</p> <p>Root command doesn't have names, but it does have <code>prog</code> to define the program name: <pre><code>params = Params(..., prog='pyparam')\n</code></pre> If not given, <code>sys.argv[0]</code> will be used.</p> <p><code>prog</code> will be used to format the description and the usage of the program.</p>"},{"location":"commands/#description","title":"Description","text":"<p>Like paramter description, you can provide a single string or a list of strings as the description. And it acts the same as the paramter description in terms of differences between single string and list of strings.</p> <p>You can also code blocks as we do for parameter descriptions. See Parameter descriptions.</p>"},{"location":"commands/#usage","title":"Usage","text":"<p>You can specify some example usages for the program. A single string or list of strings acts as the description. You can also use <code>%(prog)s</code> as a placeholder for the program name.</p> <p>By default, <code>pyparam</code> generates default usages for the program. It literally list all the required parameters and merge all optional ones as <code>[OPTIONS]</code>.</p>"},{"location":"commands/#sub-commands","title":"Sub-commands","text":"<p>Sub-commands act very similarly as the root command. But unlike the root command, they do have names, which are used from themselves to be detected from the command line. A typical way to add a command is: <code>params.add_command('command, command_alias', ...)</code> or <code>pyparam.add_command(['command', 'command_alias'], ...)</code></p> <p>A sub-command can have sub-commands, too. Just add some commands to the sub-command: <pre><code>command1 = params.add_command('cmd1, command1', ...)\nsubcommand1 = command1.add_command('subcmd1, subcommand1', ...)\n</code></pre></p> <p>You don't have to call <code>parse()</code> for sub-commands, the root command will do it once <code>params.parse()</code> is called. All descades of sub-commands' <code>parse()</code> method will be called automatically.</p> <p>The attribute <code>prog</code> for a sub-command is its parent command's prog plus <code>[OPTIONS]</code> if any and plus the longest name of the sub-command. You can replace this by <code>params.add_command(..., prog='prog command')</code>.</p> <p>Their attributes are independent of their parent command, but once absence, they will be inherited from the parent command. For example: <pre><code>params = Params(..., prefix='+')\ncommand = params.add_command('command')\n# command == '+'\n</code></pre> You can change this by: <pre><code>params = Params(..., prefix='+')\ncommand = params.add_command('command', prefix='-')\n</code></pre> Then with the parameters being added: <pre><code>params.add_param('i')\ncommand.add_param('i')\nparsed = params.parse()\n</code></pre> This: <pre><code>$ prog +i 1 command -i 2\n</code></pre> will produce <pre><code>Namespace(__command__='command',\n\t\t  i=1,\n\t\t  command=Namespace(i=2))\n</code></pre></p>"},{"location":"commands/#command-reuse","title":"Command reuse","text":"<p>To reuse a command, you can define a command in either way below: <pre><code>from pyparam import Params\n# root command\nparams = Params()\ncommand = params.add_command('cmd')\n# or\ncommand = Params('cmd')\n</code></pre> Then add it by: <pre><code>params.add_command(command)\n</code></pre> In such a case, other arguments of <code>params.add_command</code> will be ignored, except <code>force</code> and <code>group</code>.</p> <p>Note</p> <p>Unlike reuse of parameters, the <code>command</code> here is not copied. This means any changes you make on <code>command</code> will reflect on <code>params.commands['cmd']</code></p>"},{"location":"commands/#help-command","title":"Help command","text":"<p>One can invoke sub-command's help page by: <pre><code>prog help command\n</code></pre> Where help is also a sub-command, which means you can invoke the help page of the help sub-command.</p> <p>You can change the default help command by <code>params.add_command(..., help_cmds='show')</code>. Then the invoke command is like: <pre><code>prog show command\n</code></pre></p>"},{"location":"commands/#modifying-help-command","title":"Modifying help command","text":"<p>Sometimes, you may want to modify the help command, for example, its group showing in the help page. To do this, you need to define a callback and pass it to the <code>params.parse</code> function. Since the help command and the help parameters are added on the fly.</p> <pre><code>def help_modifier(help_param, help_command):\n\t# also do some modifications to help_param as well\n\thelp_command.group = 'Other commands'\n\n# params definition\nparsed = params.parse(help_modifier=help_modifier)\n</code></pre>"},{"location":"fromCommandline/","title":"Parsing from command line","text":"<p>A most common use of <code>pyparam</code> is to parse the values from command line. Parameters will be matched and values will be consumed until the end of the command line. Values will be finally compiled into a namespace.</p> <p>Note</p> <p>In this documentation, We are using <code>paramter</code> to specifically refer to the parameter that is defined with <code>pyparam</code>. For the items from command line, we call them <code>arguments</code></p>"},{"location":"fromCommandline/#argument-name-prefix","title":"Argument name prefix","text":"<p>By default, the prefix is <code>auto</code>, meaning that for short names (length &lt;= 1), it is <code>-</code>; while for long ones (length &gt; 1), it is <code>--</code>.</p> <p>You can specify your own prefix. Then all the names will be sharing the same prefix this way.</p> <p>If you have values starting with the prefix, say <code>-1</code> as a value of an int paramter, to avoid that it's parsed as a name of an argument, you may need to attach the value to the name. For example, <code>-i-1</code>, <code>-i=-1</code> or <code>--int=-1</code> (see Argument with attached value).</p> <p>Note</p> <p>We don't have any constraints on the <code>prefix</code>, but to reduce ambiguity, commonly used ones are recommended (i.e. <code>auto</code>, <code>-</code>, <code>--</code>, etc).</p> <p>Info</p> <p>Void prefix(<code>''</code>) is also supported, meaning that each element of the <code>sys.argv</code> is treated as a potential matched parameter. So the values should be attached to it (see Argument with attached value).</p> <p>For example: <pre><code>params = Params(..., prefix='')\nparams.add_param('i')\nparsed = params.parse(['i=1'])\n# parsed.i == 1\n</code></pre></p>"},{"location":"fromCommandline/#argument-with-attached-value","title":"Argument with attached value","text":"<p>Users may pass an argument with attached value with it. For example: <pre><code>prog -a1 -b=2 --count=3\n</code></pre> Each of <code>-a1</code>, <code>-b=2</code>, <code>--count=3</code> is just one element of <code>sys.argv</code>. It is easy to deal with the latter two, since we have <code>=</code> as the delimiter. However, for the first one, we don't have some limitations to parse it as <code>param_name='a', param_value='1'</code>:</p> <ol> <li> <p>No type attached. For example, these cannot be detached: <code>-i:int1</code> and <code>--float:float1.1</code> (but these can: <code>-i:int=1</code> and <code>--float:float=1.1</code>).</p> </li> <li> <p>prefix has to have length &lt;= <code>1</code> or to be <code>auto</code>. For example, if you have:    <pre><code>params = Params(..., prefix='+')\n</code></pre>    then <code>+a1</code> is also possible to be parsed as the above.    If you have <code>prefx='--'</code> then, attached value without <code>=</code> will never be detached from the name, say: <code>--a1</code>, which will always be parsed as <code>param_name='a1', param_value=None</code>.</p> </li> <li> <p><code>a1</code> is not defined as a parameter and but <code>a</code> is.    If you have <code>a1</code> defined as a parameter, then <code>-a1</code> will be anyway parsed as <code>param_name='a1', param_value=None</code>.    If neither <code>a1</code> nor <code>a</code> is defined, a warning will be shown saying that <code>-a1</code> is an unknown argument.</p> </li> <li> <p>In arbitrary mode (see Arbitrary parsing), it doesn't require <code>a</code> to be defined if <code>a1</code> is not defined (it will be always <code>param_name='a1', param_value=None</code> if it is). Parameter <code>a</code> will be defined on the fly.</p> </li> </ol>"},{"location":"fromCommandline/#help-argument","title":"Help argument","text":"<p>By default, once we hit one of <code>-h</code>, <code>-H</code> and <code>--help</code> from command line, <code>pyparam</code> will stop parsing, and print the help page.</p> <p>You can change the help argument names by: <pre><code># only with -h, --help\nparams = Params(..., help_keys='h,help')\n# or\nparams = Params(..., help_keys=['h', 'help'])\n</code></pre></p> <p>When there is not arguments detected, meaning that there is only command name passed on the command line, the help page will print by default. Sometime when you want the program to get through instead of exit and print the help page, especially when all the paramters are optional and your program is able to run with those values. You can enable this by: <pre><code>params = Params(..., help_on_void=False)\n</code></pre></p>"},{"location":"fromCommandline/#positional-argument","title":"Positional argument","text":"<p>Positional argument is not enabled by default. You will have to add it by yourself: <pre><code>from pyparam import Params, OPTIONAL\n\nparams = Params()\nparams.add_param(POSITIONAL)\nparsed = params.parse(['1', '2', '3'])\n# parsed[POSITIONAL] == [1, 2, 3]\n</code></pre></p> <p>Maybe you have already noticed that the default type of the positional argument is <code>list:auto</code>. You can change it by <code>params.add_param(POSITIONAL, type=int)</code>. Then in the above case, the last 2 values (<code>'2'</code> and <code>'3'</code>) will be ignored and <code>parsed[POSITIONAL] == 1</code></p>"},{"location":"fromCommandline/#type-overwritting","title":"Type overwritting","text":"<p>By default, type overwriting from the command line is disabled, unless your are resetting a list parameter (<code>--list:r 4 5</code>).</p> <p>To enable type overwriting from command line, you can do: <pre><code>params.add_param('i', type=int, type_frozen=False)\n</code></pre> Then from command line: <pre><code>prog -i:float 1.1\n</code></pre> is legal and the value of <code>i</code> will be a float number.</p> <p>If type overwriting is enabled, the types for the parameters will be italic and in lowercase on help page.</p>"},{"location":"fromCommandline/#arbitrary-parsing","title":"Arbitrary parsing","text":"<p>Arbitrary mode doesn't need the parameters to be pre-defined. They will be defined on the fly.</p> <p>To enable arbitrary mode: <pre><code>params = Params(..., arbitrary=True)\nparsed = params.parse()\n</code></pre></p> <p>For example: <pre><code>prog -i 1 --float 2.1 --str:str 3\n</code></pre> will produce a parsed namespace: <pre><code>Namespace(i=1, float=2.1, str=\"3\")\n</code></pre></p> <p>You can play with this by running <code>$ python -m pyparam arbi ...</code></p>"},{"location":"fromDict/","title":"Loading from dict/config file","text":""},{"location":"fromDict/#loading-parameters-from-a-dict","title":"Loading parameters from a dict","text":"<p>You can skip all those <code>add_param</code> and <code>add_command</code> calls, and load the parameter/command definition from a python dictionary.</p> <p>There are two way to do that:</p>"},{"location":"fromDict/#express-dict","title":"Express dict","text":"<p>The express way is a depth 1 dictionary where all the keys are flattened. <pre><code>from pyparam import Params\n\nparams_def = {\n    \"i\": 1, # default value\n    \"i.aliases\": [\"int\"],\n    \"i.type\": \"int\",\n    \"i.desc\": [\"An int parameter\"],\n    # ...\n    \"f\": 1.0,\n    \"f.aliases\": [\"float\"],\n    \"f.type\": \"float\",\n    \"f.desc\": [\"A float parameter\"]\n}\n\nparams = Params()\nparams.file_dict(params_def)\n# This does the same as\nparams.add_param(\"i,int\", default=1, type=int, desc=[\"An int parameter\"])\nparams.add_param(\"f,float\", default=1.0, type=float, desc=[\"A float parameter\"])\n</code></pre></p> <p>Express dict has some limitations:</p> <ol> <li>No sub-command specifications are allowed</li> <li>No namespace parameters</li> </ol>"},{"location":"fromDict/#full-specification-dict","title":"Full specification dict","text":"<p>One can use the full specification dictionary to have sub-command and namespace parameter definitions enabled:</p> <pre><code>params_def = {\n    \"params\": {\n        \"i\": {\n            \"default\": 1,\n            \"aliases\": [\"int\"],\n            \"type\": \"int\",\n            \"desc\": [\"An int parameter\"]\n        },\n        \"f\": {\n            \"default\": 1.0,\n            \"aliases\": [\"float\"],\n            \"type\": \"float\",\n            \"desc\": [\"A float parameter\"]\n        }\n    },\n    \"commands\": {\n        \"cmd\": {\n            # aliases: [...]\n            # prefix: ...\n            \"params\": {\n                \"c\": {\n                    \"default\": \"medium\",\n                    \"type\": \"choice\",\n                    \"choices\": [\"small\", \"medium\", \"large\"]\n                },\n                \"config\": {\n                    \"type\": \"ns\",\n                    \"desc\": \"A set of configurations\"\n                },\n                \"config.ncores\": {\n                    \"default\": 4,\n                    \"desc\": \"Number of cores\"\n                }\n            }\n        }\n    }\n}\nparams.from_dict(params_def)\nparsed = params.parse()\n</code></pre> <p>This: <pre><code>prog -i 1 -f 2.0 cmd -c large --config.ncores 1\n</code></pre> will produce: <pre><code>Namesapce(__command__='cmd',\n          i=1,\n          f=2.0,\n          cmd=Namesapce(c='large', config=Namesapce(ncores=1)))\n</code></pre></p>"},{"location":"fromDict/#hiding-parameters-from-help-page","title":"Hiding parameters from help page","text":"<p>If you don't want a parameter to be shown in help page, especially when it not required, just pass <code>show=False</code> to it. In the dictionary, you can just do: <pre><code>params_def = {\n    \"x\": 1,\n    \"x.show\": False\n}\n</code></pre> Or with full specification: <pre><code>params_def = {\n    \"params\": {\n        \"x\": {\n            \"default\": 1,\n            \"show\": False\n        }\n    }\n}\n</code></pre></p> <p>Or if you want to hide all the parameters from a dict except those with <code>show=True</code> explictly: <pre><code>params.from_dict(params_def, show=False)\n</code></pre></p>"},{"location":"fromDict/#loading-from-a-configuration-file","title":"Loading from a configuration file","text":"<p>Parameters can also be loaded from a configuration file that is supported by <code>python-simpleconf</code></p> <p>Those configuration files will be first read and turned into python dictionary, and then parameter definitions will be loaded using <code>params.from_dict</code>.</p> <p>There is the <code>toml</code> file that are the same as the above dict examples.</p> <ul> <li> <p>Express:</p> <pre><code>i = 1\n\"i.aliases\" = [\"int\"]\n\"i.type\" = \"int\"\n\"i.desc\" = [\"An int parameter\"]\n# ...\nf = 1.0\n\"f.aliases\" = [\"float\"]\n\"f.type\" = \"float\"\n\"f.desc\" = [\"A float parameter\"]\n</code></pre> </li> <li> <p>Full specification</p> <pre><code>[params.i]\ndefault = 1\naliases = [\"int\"]\ntype = \"int\"\ndesc = \"An int parameter\"\n\n[params.f]\ndefault = 1.0\naliases = [\"float\"]\ntype = \"float\"\ndesc = [\"A float parameter\"]\n\n[commands.cmd.params.c]\ndefault = \"medium\"\ntype = \"choice\"\nchoices = [\"small\", \"medium\", \"large\"]\n\n[commands.cmd.params.config]\ntype = \"ns\"\ndesc = \"A set of configurations\"\n\n  [commands.cmd.params.\"config.ncores\"]\n  default = 4\n  desc = \"Number of cores\"\n</code></pre> </li> </ul>"},{"location":"fromDict/#loading-from-a-configuration-file-specified-by-a-command-line-argument","title":"Loading from a configuration file specified by a command line argument","text":"<p>You may also ask user to specify a configuration file to load parameter/command definitions from.</p> <p>Something like: <pre><code>prog --config-file params_def.toml -i 1 -f 2.0 ...\n</code></pre> Then the parameter/command definitions will be loaded from <code>params_def.toml</code>.</p> <p>To do it: <pre><code>params.from_arg('config-file')\n</code></pre></p> <p>First, <code>pyparam</code> will scan the <code>sys.argv</code> to see if any item matches <code>--config-file</code>. If it does, then the next item (<code>params_def.toml</code>) will be used.</p> <p>To show the paramter <code>config-file</code> in the help page, you can also specify some desciptions to it: <pre><code>params.from_arg('config-file', desc=..., group=...)\n</code></pre></p> <p>To use full configuration of a parameter, one can also add it as a parameter first: <pre><code>configfile = params.add_params('config-file', ...)\n# then\nparams.from_arg(configfile)\n</code></pre></p> <p>Tip</p> <p><code>from_dict</code>, <code>from_file</code> and <code>from_arg</code> have a <code>force</code> argument to force adding parameters/commands, if they exist. Basically later ones will overwrite existing ones.</p>"},{"location":"fromDict/#dumping-all-params-to-a-dict-or-file","title":"Dumping all params to a dict or file","text":"<p>You can dump all parameters and commands into a file, which later on can be loaded by <code>params</code>. This is useful when the parameters/commands take time to load.</p> <p>You can just do <code>params.to_dict()</code> or <code>params.to_file(...)</code>. You can directly specify the file path, the type will be automatically detected from the extension. Currently supported extensions are <code>.yaml</code>, <code>.yml</code>, <code>.json</code> and <code>.toml</code>. Otherwise you can specify the type by <code>cfgtype</code> argument. Supported <code>cfgtype</code>s are <code>yaml</code>, <code>json</code> and <code>toml</code>.</p>"},{"location":"fromDict/#skipping-command-line-argument-parsing","title":"Skipping command line argument parsing","text":"<p><code>pyparam</code> can also work as a value holder, which does not parse anything from the command line, but just use the predefined values. This requires all the parameters are optional and no command has been defined.</p> <p>For example: <pre><code>params.add_param('i', default=0)\nparams.values() # Namespace(i=0)\n</code></pre></p> <p>Parameter callbacks are still applicable here.</p>"},{"location":"helpPage/","title":"Help page","text":""},{"location":"helpPage/#grouping-parameterscommands","title":"Grouping parameters/commands","text":"<p>On the help page, parameters/commands are put in groups. You can specify the group for a parameter or command by <code>params.add_param(..., group=xxx)</code> or <code>params.add_command(..., group=xxx)</code></p> <p>If not specified, we have default groups assigned for them</p>"},{"location":"helpPage/#default-group","title":"Default group","text":"<p>Optional parameters will be in group <code>OPTIONAL OPTIONS</code>, and required parameters will be in group <code>REQUIRED OPTIONS</code>.</p> <p>For a namespace parameter, if any paramters under it is required, then the namespace parameter is required, otherwise it optional. Those parameters under a namespace parameter will be grouped as something like <code>OPTIONAL OPTIONS UNDER --config</code>.</p> <p>Sub-commands are grouped into <code>COMMANDS</code></p>"},{"location":"helpPage/#manipulating-help-page","title":"Manipulating help page","text":"<p>You are able to modify the help page yourself. Just pass a callback funtion to <code>Params</code>: <pre><code>params = Params(..., help_callback=...)\n</code></pre></p> <p>A help callback function takes only one argument, which is a <code>OrderedDiot</code> object (A dot-notation enabled <code>OrderedDict</code> by <code>diot</code>). Each key is a section title and value is the corresponding content of that section. The content be one of <code>HelpSectionPlain</code>, <code>HelpSectionUsage</code> and <code>HelpSectionOption</code> objects. They are basically subclasses of <code>list</code>. The elements of first two are just strings; while they are 2-element tuples for the last one. Those two elements are lists of parameter names/types and descriptions.</p> <p>Here are the examples on how you can manipulate the help page.</p> <ul> <li> <p>Without callback:     <pre><code>from pyparam import Params\nparams = Params(prog='pyparam')\nparams.add_param('i')\nparams.print_help()\n</code></pre></p> <p>DESCRIPTION:   No description</p> <p>USAGE:   pyparam [OPTIONS]</p> <p>OPTIONAL OPTIONS:   -i                         - No description. Default: None <li> <p>Adding a section     <pre><code>from pyparam import Params\nfrom pyparam.help import HelpSectionPlain\ndef help_callback(assembled):\n    assembled.SEE = HelpSectionPlain(\n        ['See: https://github.com/pwwang/pyparam']\n    )\n\nparams = Params(prog='pyparam', help_callback=help_callback)\n# add paramters and print help\n</code></pre></p> <pre><code>DESCRIPTION:\n  No description\n\nUSAGE:\n  pyparam [OPTIONS]\n\nOPTIONAL OPTIONS:\n  -i &lt;AUTO&gt;                        - No description. Default: None\n\nSEE:\n  See: https://github.com/pwwang/pyparam\n</code></pre> <p>You can also insert a section to a certain position: <pre><code>assembled.insert(0, \"SEE\", HelpSectionPlain(...))\n# or insert before or after a section\nassembled.insert_after('DESCRIPTION', \"SEE\", HelpSectionPlain(...))\n</code></pre></p> <p>To add a option section (with option name, type and descriptions): <pre><code>from pyparam.help import HelpSectionOption\ndef help_callback(assembled):\n    assembled['EXTRA OPTIONS'] = HelpSectionOption([\n        (['-i, --int &lt;INT&gt;'], ['An int paramter', 'Default: 0']),\n        (['-f, --float &lt;FLOAT&gt;'], ['An float paramter', 'Default: 0.0']),\n    ])\n</code></pre></p> </li> <li> <p>Removing a section:     <pre><code>del assembled['DESCRIPTION']\n</code></pre></p> </li> <li> <p>Modify a section:     <pre><code># it is just a list!\nassembled.DESCRIPTION[0] = 'Awesome program!'\n</code></pre></p> <pre><code>DESCRIPTION:\n  Awesome progrom!\n\nUSAGE:\n  pyparam [OPTIONS]\n\nOPTIONAL OPTIONS:\n  -i &lt;AUTO&gt;                        - No description. Default: None\n</code></pre> </li>"},{"location":"helpPage/#changing-the-size-of-help-page","title":"Changing the size of help page","text":"<p>Default sizes of the help page are defined in <code>pyparam.defaults</code>.</p> <p>To change them: <pre><code>from pyparam import defaults\n\n# Total width of the help page\n# change it to None to spread the help page with full terminal width\ndefaults.CONSOLE_WIDTH = 100\n# indention for the contents of each section\ndefaults.HELP_SECTION_INDENT = 2\n# The width of the name/type part in HelpSectionOption\ndefaults.HELP_OPTION_WIDTH = 34\n# For exapmle:\n#     OPTIONAL OPTIONS:\n#       -i, --int &lt;INT&gt;                  - An integer argument. Default: 0\n#     |&lt;-------------------------- CONSOLE_WIDTH -----------------------------------&gt;|\n#   -&gt;||&lt;-  HELP_SECTION_INDENT\n#     |&lt;----- HELP_OPTION_WIDTH -------&gt;|\n</code></pre></p>"},{"location":"helpPage/#theming","title":"Theming","text":"<p>For now, there are two builtin themes: <code>default</code> (default theme) and <code>synthware</code>. The <code>synthware</code> is from the vscode theme <code>synthware' 84</code>, and using some color combinations from there.</p> <p>You can specify your own theme by: <pre><code>from rith.theme import Theme\nparams = Params(..., theme=Theme({\n    # The section title\n    'title': \"bold cyan\",\n    # Highlight program name\n    'prog': \"bold green\",\n    # Highlight default value in parameter description\n    'default': \"magenta\",\n    # Highlight option names\n    'optname': \"bright_green\",\n    # Highlight option types when type overwriting is enabled\n    'opttype': \"blue italic\",\n    # Highlight option types when it is disabled\n    'opttype_frozen': \"blue\"\n}))\n</code></pre></p> <p>See more details in rich's documentation.</p>"},{"location":"shellCompletion/","title":"Shell completion","text":"<p><code>pyparam</code> supports shell completions for <code>bash</code>, <code>zsh</code> and <code>fish</code>. It also supports the script to be ran as a python script (in the format of <code>python myscript.py</code>) and as a python module (in the format of <code>python -m myscript</code>).</p> <p>To enable the completions, you will have to print the code generated by <code>params.shellcode(...)</code>, and let the user save it at required locations for the shell to initiate the completion.</p> <p><code>params.shellcode</code> has 3 arguments that generates codes for direct executables, python scripts and python modules.</p> <ul> <li>Argument <code>shell</code>: Specifies the shell (One of <code>bash</code>, <code>zsh</code> and <code>fish</code>)</li> <li>Argument <code>python</code>: Once specified, program will be ran as a python script or a module.   It specifies the path or name to the python you used to run your script or your module.   For example, if your python executable is <code>python3.8</code>, you will need to specify <code>python3.8</code>.   In this case, your program name has to be the path to <code>myscript.py</code>, for example.</li> <li>Argument <code>module</code>: Whether the program is running as a python module.   <code>python</code> will be used if specified and your program name need to be the name of the module (<code>myscript</code>, for example).</li> </ul> <p>Let's say you have <code>$ myscript shellcode</code> calling <code>params.shellcode(...)</code> and printing the code:</p>"},{"location":"shellCompletion/#completions-for-bash","title":"Completions for bash","text":"<pre><code>$ myscript shellcode &gt;&gt; ~/.bashrc\n</code></pre>"},{"location":"shellCompletion/#completions-for-fish","title":"Completions for fish","text":"<p>For direct executable: <pre><code>$ myscript shellcode &gt;&gt; ~/.config/fish/completions/myscript.fish\n</code></pre> For python script or module: <pre><code>$ myscript shellcode &gt;&gt; ~/.config/fish/completions/python.fish\n$ #     corresponding to your python executable:   ^^^^^^\n</code></pre></p>"},{"location":"shellCompletion/#completions-for-zsh","title":"Completions for zsh","text":"<pre><code>$ myscript shellcode &gt;&gt; ~/.zshrc\n</code></pre> <p>If you encounter <code>command not found: compdef</code>, make sure you have this before the inserted code: <pre><code>autoload -Uz compinit\ncompinit\n</code></pre></p>"},{"location":"shellCompletion/#completion-value-callback","title":"Completion value callback","text":"<p>When define a parameter, you can also specify a callback to modify how the completion works for the values. For example, to add some description for a <code>choice</code> parameter: <pre><code>def complete_callback(current, prefix):\n    completes = []\n    for value in ['xsmall', 'small', 'medium', 'large', 'xlarge']:\n        # only show the value matches user's incomplete input\n        if value.startswith(current):\n            # prefix makes it works with `--choice=...`\n            # Add some description for each value\n            completes.append((f'{prefix}{value}', f'Cup size: {value}'))\n    return completes\n\nparams.add_param('choice', type='choice',\n                 choices=['xsmall', 'small', 'medium', 'large', 'xlarge'],\n                 complete_callback=complete_callback)\n</code></pre></p> <p>This is how it looks like in <code>fish</code>: <pre><code>&gt; python -m pyparam complete --choice &lt;tab&gt;\nlarge    (Cup size: large)  small    (Cup size: small)\nxsmall  (Cup size: xsmall)  medium  (Cup size: medium)\nxlarge  (Cup size: xlarge)\n\n&gt; python -m pyparam complete --choice x&lt;tab&gt;\nxlarge  (Cup size: xlarge)  xsmall  (Cup size: xsmall)\n</code></pre></p> <p>Without the callback: <pre><code>&gt; python -m pyparam complete --choice &lt;tab&gt;\nlarge  medium  small  xlarge  xsmall\n\n&gt; python -m pyparam complete --choice x&lt;tab&gt;\nxlarge  xsmall\n</code></pre></p> <p>The callback should return:</p> <ul> <li><code>None</code>: no completion candidates given, meaning it's requiring user to input a value</li> <li><code>''</code>: An empty string, meaning we are done with the this parameter, go ahead to next available ones.</li> <li> <p>A list of tuple of:</p> <ul> <li>1-element: Shows just the value, without description</li> <li>2-element: Shows both the value and the description</li> <li>3-element: Shows the value, type and the description</li> </ul> <p>There are 3 types of completion candidates. <code>plain</code>, <code>file</code> and <code>dir</code>. In most cases, it's <code>plain</code>. But if you want to complete <code>file</code> or <code>dir</code>, you should return a list of 3-element tuples. Those 3 elements should be:</p> <ul> <li> <p><code>current</code>: the current incomplete user-input, used to filter the paths (the <code>current</code> argument).</p> </li> <li> <p><code>type</code>: either <code>file</code> or <code>dir</code></p> </li> <li> <p><code>prefix</code>: the <code>prefix</code> argument, used to do completion for <code>--path=...</code></p> </li> </ul> </li> </ul> <p>Note</p> <p><code>file</code> type of completions will also show directories.</p> <p>Note</p> <p>When a command has required parameters uncompleted, no subcommands will show in the candidates.</p> <p>For example, in your script: <pre><code>params.add_param('i', required=True)\nparams.add_command('command')\n</code></pre></p> <p>Then: <pre><code>&gt; script &lt;tab&gt;\n-i  (No description)\n</code></pre> will only show the required parameter, command will not show until the required parameters are filled.</p>"},{"location":"shellCompletion/#enabling-completion-in-your-script","title":"Enabling completion in your script","text":"<p>Make sure you call <code>params.parse(...)</code> after all parameters/commands defined to make those shell code work.</p>"},{"location":"useTheValues/","title":"Using the parsed values","text":"<p>The parsed values by <code>params.parse()</code> or <code>params.values()</code> are attached to a namespace. Yes, <code>argparse</code>'s <code>Namespace</code>. So this will be true:</p> <pre><code>from argparse import Namespace\nfrom params import Params\nparams.add_param('i', default=1)\nvalues = params.values()\n\nisinstance(values, Namespace)\n</code></pre> <p>However, it is not exactly the same, meaning this is NOT true: <pre><code>from argparse import Namespace as APNamespace\nfrom params import PMNamespace\nPMNamespace is APNamespace\n</code></pre></p> <p>But <code>PMNamespace</code> is a subclass of <code>APNamespace</code>, with following functionalities being added:</p> <ul> <li> <p>Subscription:     <pre><code>ns = PMNamespace()\nns['a'] = 1\nns['a'] == 1\n</code></pre></p> </li> <li> <p>Length:     <pre><code>len(ns['a']) == 1\n</code></pre></p> </li> <li> <p>Key existence detection:     <pre><code>'a' in ns is True\n</code></pre></p> </li> </ul> <p>You can turn a namespace into a dictionary by <code>vars(ns)</code>. However, if you want to turned all the namespaces inside into dictionaries, you may need to do it recursively.</p>"},{"location":"api/pyparam.completer/","title":"pyparam.completer","text":"module &lt;/&gt; <p>Classes for completions</p> <p>The idea is inspired from https://github.com/pallets/click/pull/1622</p> <p>Some of the code is borrowing there, under following LICENSE:</p> <p>Copyright 2014 Pallets</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p> Classes <ul> <li><code>Completer</code> \u2014 Main completion handler&lt;/&gt;</li> <li><code>CompleterParam</code> \u2014 Class for a parameter dealing with completion&lt;/&gt;</li> </ul> Functions <ul> <li><code>split_arg_string</code><code>(</code><code>string</code><code>)</code> (list of str) \u2014 Given an argument string this attempts to split it into small parts.&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Given an argument string this attempts to split it into small parts.</p> <p>Borrowed from https://github.com/pallets/click/blob/3984f9efce5a0d15f058e1abe1ea808c6abd243a/src/click/parser.py#L106</p> Parameters <ul> <li><code>string</code> (str) \u2014 The string to be split</li> </ul> Returns (list of str) <p>List of split pieces</p> class &lt;/&gt; <p>Main completion handler</p> Attributes <ul> <li><code>comp_curr</code> (str) \u2014 The current word for completion</li> <li><code>comp_prev</code> (str) \u2014 The previous word matched</li> <li><code>comp_shell</code> (str) \u2014 The shell where the completion will be conducted One of ['', 'bash', 'fish', 'zsh'] Obtained from environment</li> <li><code>comp_words</code> (list of str) \u2014 The words have been entered before completion</li> <li><code>progvar</code> (str) \u2014 Get the program name that can be used as a variable&lt;/&gt;</li> <li><code>uid</code> (str) \u2014 Get the uid based on the raw program name This is used as the prefix or suffix of some shell function names&lt;/&gt;</li> </ul> Methods <ul> <li><code>complete</code><code>(</code><code>)</code> (str) \u2014 Yields the completions&lt;/&gt;</li> <li><code>shellcode</code><code>(</code><code>shell</code>, <code>python</code>, <code>module</code><code>)</code> (str) \u2014 Generate the shell code to be integrated&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Generate the shell code to be integrated</p> <p>For bash, it should be appended to ~/.profile For zsh, it should be appended to ~/.zprofile For fish, it should be appended to     ~/.config/fish/completions/%(prog)s.fish     If python is provided, this should go to <code>python.fish</code> rather than     the <code>%(prog)s.fish</code></p> Parameters <ul> <li><code>shell</code> (str) \u2014 The shell to generate the code for.</li> <li><code>python</code> (str, optional) \u2014 The python name or path to invoke completion.</li> <li><code>module</code> (bool, optional) \u2014 Whether do completion for <code>python -m &lt;prog&gt;</code></li> </ul> Raises <ul> <li><code>ValueError</code> \u2014 if shell is not one of bash, zsh and fish</li> </ul> generator &lt;/&gt; <p>Yields the completions</p> Yields (str) <p>The strings as completion candidates</p> class &lt;/&gt; <p>Class for a parameter dealing with completion</p> Methods <ul> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p>"},{"location":"api/pyparam.completer/#pyparamcompleter","title":"pyparam.completer","text":""},{"location":"api/pyparam.completer/#pyparamcompletersplit_arg_string","title":"<code>pyparam.completer.</code><code>split_arg_string</code><code>(</code><code>string</code><code>)</code>","text":""},{"location":"api/pyparam.completer/#pyparamcompletercompleter","title":"<code>pyparam.completer.</code><code>Completer</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.completer/#pyparamcompletercompletershellcode","title":"<code>shellcode</code><code>(</code><code>shell</code>, <code>python=None</code>, <code>module=False</code><code>)</code> \u2192 str","text":""},{"location":"api/pyparam.completer/#pyparamcompletercompletercomplete","title":"<code>complete</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.completer/#pyparamcompletercompleterparam","title":"<code>pyparam.completer.</code><code>CompleterParam</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.completer/#pyparamcompletercompleterparamcomplete_value","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.completer/#pyparamcompletercompleterparamcomplete_name","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.defaults/","title":"pyparam.defaults","text":"module &lt;/&gt; <p>Defaults for pyparam</p> <p>Holds some default values for pyparam. To change any of the CONSOLE_WIDTH, HELP_SECTION_INDENT or HELP_OPTION_WIDTH: <pre><code>from pyparam import defaults\ndefault.CONSOLE_WIDTH = 100\n</code></pre></p> Attributes <ul> <li><code>CONSOLE_WIDTH</code> (int) \u2014 The total width for the help page.</li> <li><code>HELP_OPTION_WIDTH</code> (int) \u2014 The width that the option name and type take up in the help page.</li> <li><code>HELP_SECTION_INDENT</code> (int) \u2014 The indentation for the contents in a section</li> <li><code>POSITIONAL</code> (str) \u2014 The name of positional parameter</li> <li><code>TYPE_NAMES</code> (dict(str: str)) \u2014 The type name mappings to get the type name from aliases Do not modify this variable. It is maintained by <code>pyparam.param.regiest_param</code></li> </ul>"},{"location":"api/pyparam.defaults/#pyparamdefaults","title":"pyparam.defaults","text":""},{"location":"api/pyparam.exceptions/","title":"pyparam.exceptions","text":"module &lt;/&gt; <p>Exceptions used in pyparam</p> Classes <ul> <li><code>PyParamException</code> \u2014 Base exception for pyparam&lt;/&gt;</li> <li><code>PyParamTypeError</code> \u2014 When parameter type is not supported&lt;/&gt;</li> <li><code>PyParamValueError</code> \u2014 When parameter value is improper&lt;/&gt;</li> <li><code>PyParamNameError</code> \u2014 Any errors related to parameter names&lt;/&gt;</li> </ul> class &lt;/&gt; Bases Exception BaseException <p>Base exception for pyparam</p> class &lt;/&gt; Bases pyparam.exceptions.PyParamException Exception BaseException <p>When parameter type is not supported</p> class &lt;/&gt; Bases pyparam.exceptions.PyParamException Exception BaseException <p>When parameter value is improper</p> class &lt;/&gt; Bases pyparam.exceptions.PyParamException Exception BaseException <p>Any errors related to parameter names</p>"},{"location":"api/pyparam.exceptions/#pyparamexceptions","title":"pyparam.exceptions","text":""},{"location":"api/pyparam.exceptions/#pyparamexceptionspyparamexception","title":"<code>pyparam.exceptions.</code><code>PyParamException</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.exceptions/#pyparamexceptionspyparamtypeerror","title":"<code>pyparam.exceptions.</code><code>PyParamTypeError</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.exceptions/#pyparamexceptionspyparamvalueerror","title":"<code>pyparam.exceptions.</code><code>PyParamValueError</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.exceptions/#pyparamexceptionspyparamnameerror","title":"<code>pyparam.exceptions.</code><code>PyParamNameError</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.help/","title":"pyparam.help","text":"module &lt;/&gt; <p>Help assembler for pyparam</p> Attributes <ul> <li><code>THEMES</code> (dict(str: Theme)) \u2014 The theme for the help page.</li> </ul> Classes <ul> <li><code>ProgHighlighter</code> \u2014 Apply style to anything that looks like a program name.&lt;/&gt;</li> <li><code>OptnameHighlighter</code> \u2014 Apply style to anything that looks like a option name.&lt;/&gt;</li> <li><code>OpttypeHighlighter</code> \u2014 Apply style to anything that looks like a option type.&lt;/&gt;</li> <li><code>DefaultHighlighter</code> \u2014 Apply style to anything that looks like default value in option desc.&lt;/&gt;</li> <li><code>HelpSection</code> \u2014 Base class for all help sections.&lt;/&gt;</li> <li><code>HelpSectionPlain</code> \u2014 Plain text section&lt;/&gt;</li> <li><code>HelpSectionUsage</code> \u2014 Usage section in help&lt;/&gt;</li> <li><code>HelpSectionOption</code> \u2014 Options section in help&lt;/&gt;</li> <li><code>HelpAssembler</code> \u2014 Assemble a help page&lt;/&gt;</li> </ul> class &lt;/&gt; Bases rich.highlighter.RegexHighlighter rich.highlighter.Highlighter <p>Apply style to anything that looks like a program name.</p> Parameters <ul> <li><code>prog</code> (str) \u2014 The program name</li> </ul> Methods <ul> <li><code>__call__</code><code>(</code><code>text</code><code>)</code> (Text) \u2014 Highlight a str or Text instance.&lt;/&gt;</li> <li><code>highlight</code><code>(</code><code>text</code><code>)</code> \u2014 Highlight :class:<code>rich.text.Text</code> using regular expressions.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Highlight a str or Text instance.</p> Parameters <ul> <li><code>text</code> (Union[str, ~Text]) \u2014 Text to highlight.</li> </ul> Raises <ul> <li><code>TypeError</code> \u2014 If not called with text or str.</li> </ul> Returns (Text) <p>A test instance with highlighting applied.</p> method &lt;/&gt; <p>Highlight :class:<code>rich.text.Text</code> using regular expressions.</p> Parameters <ul> <li><code>text</code> (~Text) \u2014 Text to highlighted.</li> </ul> class &lt;/&gt; Bases rich.highlighter.RegexHighlighter rich.highlighter.Highlighter <p>Apply style to anything that looks like a option name.</p> <p>Highlight <code>-b</code> and <code>--box</code> in <code>-b, --box &lt;INT&gt;</code>, and all in commands: <code>i, install</code></p> Methods <ul> <li><code>__call__</code><code>(</code><code>text</code><code>)</code> (Text) \u2014 Highlight a str or Text instance.&lt;/&gt;</li> <li><code>highlight</code><code>(</code><code>text</code><code>)</code> \u2014 Highlight :class:<code>rich.text.Text</code> using regular expressions.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Highlight a str or Text instance.</p> Parameters <ul> <li><code>text</code> (Union[str, ~Text]) \u2014 Text to highlight.</li> </ul> Raises <ul> <li><code>TypeError</code> \u2014 If not called with text or str.</li> </ul> Returns (Text) <p>A test instance with highlighting applied.</p> method &lt;/&gt; <p>Highlight :class:<code>rich.text.Text</code> using regular expressions.</p> Parameters <ul> <li><code>text</code> (~Text) \u2014 Text to highlighted.</li> </ul> class &lt;/&gt; Bases rich.highlighter.RegexHighlighter rich.highlighter.Highlighter <p>Apply style to anything that looks like a option type.</p> Methods <ul> <li><code>__call__</code><code>(</code><code>text</code><code>)</code> (Text) \u2014 Highlight a str or Text instance.&lt;/&gt;</li> <li><code>highlight</code><code>(</code><code>text</code><code>)</code> \u2014 Highlight :class:<code>rich.text.Text</code> using regular expressions.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Highlight a str or Text instance.</p> Parameters <ul> <li><code>text</code> (Union[str, ~Text]) \u2014 Text to highlight.</li> </ul> Raises <ul> <li><code>TypeError</code> \u2014 If not called with text or str.</li> </ul> Returns (Text) <p>A test instance with highlighting applied.</p> method &lt;/&gt; <p>Highlight :class:<code>rich.text.Text</code> using regular expressions.</p> Parameters <ul> <li><code>text</code> (~Text) \u2014 Text to highlighted.</li> </ul> class &lt;/&gt; Bases rich.highlighter.RegexHighlighter rich.highlighter.Highlighter <p>Apply style to anything that looks like default value in option desc.</p> Methods <ul> <li><code>__call__</code><code>(</code><code>text</code><code>)</code> (Text) \u2014 Highlight a str or Text instance.&lt;/&gt;</li> <li><code>highlight</code><code>(</code><code>text</code><code>)</code> \u2014 Highlight :class:<code>rich.text.Text</code> using regular expressions.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Highlight a str or Text instance.</p> Parameters <ul> <li><code>text</code> (Union[str, ~Text]) \u2014 Text to highlight.</li> </ul> Raises <ul> <li><code>TypeError</code> \u2014 If not called with text or str.</li> </ul> Returns (Text) <p>A test instance with highlighting applied.</p> method &lt;/&gt; <p>Highlight :class:<code>rich.text.Text</code> using regular expressions.</p> Parameters <ul> <li><code>text</code> (~Text) \u2014 Text to highlighted.</li> </ul> class &lt;/&gt; Bases list <p>Base class for all help sections.</p> Methods <ul> <li><code>__rich_console__</code><code>(</code><code>console</code>, <code>_</code><code>)</code> (ConsoleRenderable, RichCast, str, or Segment) \u2014 Implement API from rich to print the help page&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Implement API from rich to print the help page</p> class &lt;/&gt; Bases pyparam.help.HelpSection list <p>Plain text section</p> Methods <ul> <li><code>__rich_console__</code><code>(</code><code>console</code>, <code>_</code><code>)</code> (ConsoleRenderable, RichCast, str, or Segment) \u2014 Implement API from rich to print the help page&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Implement API from rich to print the help page</p> class &lt;/&gt; Bases pyparam.help.HelpSectionPlain pyparam.help.HelpSection list <p>Usage section in help</p> Methods <ul> <li><code>__rich_console__</code><code>(</code><code>console</code>, <code>_</code><code>)</code> (ConsoleRenderable, RichCast, str, or Segment) \u2014 Implement API from rich to print the help page&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Implement API from rich to print the help page</p> class &lt;/&gt; Bases pyparam.help.HelpSection list <p>Options section in help</p> Methods <ul> <li><code>__rich_console__</code><code>(</code><code>console</code>, <code>_</code><code>)</code> (ConsoleRenderable, RichCast, str, or Segment) \u2014 Implement API from rich to print the help page&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Implement API from rich to print the help page</p> class &lt;/&gt; <p>Assemble a help page</p> Parameters <ul> <li><code>prog</code> (str) \u2014 The name of the program</li> <li><code>theme</code> (str or Theme) \u2014 The theme for the help page</li> </ul> Attributes <ul> <li><code>callback</code> (callable) \u2014 The callback to modify the help page</li> <li><code>console</code> (Console) \u2014 The console to print the help page</li> </ul> Methods <ul> <li><code>assemble</code><code>(</code><code>params</code>, <code>full</code><code>)</code> \u2014 Assemble the help page&lt;/&gt;</li> <li><code>printout</code><code>(</code><code>)</code> \u2014 Print the help page&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Assemble the help page</p> Parameters <ul> <li><code>params</code> (Params) \u2014 The params object</li> </ul> method &lt;/&gt; <p>Print the help page</p>"},{"location":"api/pyparam.help/#pyparamhelp","title":"pyparam.help","text":""},{"location":"api/pyparam.help/#pyparamhelpproghighlighter","title":"<code>pyparam.help.</code><code>ProgHighlighter</code><code>(</code><code>prog</code><code>)</code>","text":""},{"location":"api/pyparam.help/#richhighlighterhighlightercall","title":"<code>__call__</code><code>(</code><code>text</code><code>)</code>","text":""},{"location":"api/pyparam.help/#richhighlighterregexhighlighterhighlight","title":"<code>highlight</code><code>(</code><code>text</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelpoptnamehighlighter","title":"<code>pyparam.help.</code><code>OptnameHighlighter</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.help/#richhighlighterhighlightercall_1","title":"<code>__call__</code><code>(</code><code>text</code><code>)</code>","text":""},{"location":"api/pyparam.help/#richhighlighterregexhighlighterhighlight_1","title":"<code>highlight</code><code>(</code><code>text</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelpopttypehighlighter","title":"<code>pyparam.help.</code><code>OpttypeHighlighter</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.help/#richhighlighterhighlightercall_2","title":"<code>__call__</code><code>(</code><code>text</code><code>)</code>","text":""},{"location":"api/pyparam.help/#richhighlighterregexhighlighterhighlight_2","title":"<code>highlight</code><code>(</code><code>text</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelpdefaulthighlighter","title":"<code>pyparam.help.</code><code>DefaultHighlighter</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.help/#richhighlighterhighlightercall_3","title":"<code>__call__</code><code>(</code><code>text</code><code>)</code>","text":""},{"location":"api/pyparam.help/#richhighlighterregexhighlighterhighlight_3","title":"<code>highlight</code><code>(</code><code>text</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelphelpsection","title":"<code>pyparam.help.</code><code>HelpSection</code><code>(</code><code>iterable=()</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelphelpsectionrich_console","title":"<code>__rich_console__</code><code>(</code><code>console</code>, <code>_</code><code>)</code> \u2192 ConsoleRenderable, RichCast, str, or Segment","text":""},{"location":"api/pyparam.help/#pyparamhelphelpsectionplain","title":"<code>pyparam.help.</code><code>HelpSectionPlain</code><code>(</code><code>iterable=()</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelphelpsectionrich_console_1","title":"<code>__rich_console__</code><code>(</code><code>console</code>, <code>_</code><code>)</code> \u2192 ConsoleRenderable, RichCast, str, or Segment","text":""},{"location":"api/pyparam.help/#pyparamhelphelpsectionusage","title":"<code>pyparam.help.</code><code>HelpSectionUsage</code><code>(</code><code>iterable=()</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelphelpsectionusagerich_console","title":"<code>__rich_console__</code><code>(</code><code>console</code>, <code>_</code><code>)</code> \u2192 ConsoleRenderable, RichCast, str, or Segment","text":""},{"location":"api/pyparam.help/#pyparamhelphelpsectionoption","title":"<code>pyparam.help.</code><code>HelpSectionOption</code><code>(</code><code>iterable=()</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelphelpsectionoptionrich_console","title":"<code>__rich_console__</code><code>(</code><code>console</code>, <code>_</code><code>)</code> \u2192 ConsoleRenderable, RichCast, str, or Segment","text":""},{"location":"api/pyparam.help/#pyparamhelphelpassembler","title":"<code>pyparam.help.</code><code>HelpAssembler</code><code>(</code><code>prog</code>, <code>theme</code>, <code>callback</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelphelpassemblerassemble","title":"<code>assemble</code><code>(</code><code>params</code>, <code>full=False</code><code>)</code>","text":""},{"location":"api/pyparam.help/#pyparamhelphelpassemblerprintout","title":"<code>printout</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam/","title":"pyparam","text":"package &lt;/&gt; <p>Powerful parameter processing with pyparam</p> module &lt;/&gt; <p>Defaults for pyparam</p> <p>Holds some default values for pyparam. To change any of the CONSOLE_WIDTH, HELP_SECTION_INDENT or HELP_OPTION_WIDTH: <pre><code>from pyparam import defaults\ndefault.CONSOLE_WIDTH = 100\n</code></pre></p> Attributes <ul> <li><code>CONSOLE_WIDTH</code> (int) \u2014 The total width for the help page.</li> <li><code>HELP_OPTION_WIDTH</code> (int) \u2014 The width that the option name and type take up in the help page.</li> <li><code>HELP_SECTION_INDENT</code> (int) \u2014 The indentation for the contents in a section</li> <li><code>POSITIONAL</code> (str) \u2014 The name of positional parameter</li> <li><code>TYPE_NAMES</code> (dict(str: str)) \u2014 The type name mappings to get the type name from aliases Do not modify this variable. It is maintained by <code>pyparam.param.regiest_param</code></li> </ul> module &lt;/&gt; <p>Exceptions used in pyparam</p> Classes <ul> <li><code>PyParamException</code> \u2014 Base exception for pyparam&lt;/&gt;</li> <li><code>PyParamTypeError</code> \u2014 When parameter type is not supported&lt;/&gt;</li> <li><code>PyParamValueError</code> \u2014 When parameter value is improper&lt;/&gt;</li> <li><code>PyParamNameError</code> \u2014 Any errors related to parameter names&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Definition of a single parameter</p> Attributes <ul> <li><code>PARAM_MAPPINGS</code> (dict(str: type of Param)) \u2014 The type to Param mappings, used for params to init a parameter. Managed by <code>register_param</code></li> </ul> Classes <ul> <li><code>Param</code> \u2014 Base class for parameter&lt;/&gt;</li> <li><code>ParamAuto</code> \u2014 An auto parameter whose value is automatically casted&lt;/&gt;</li> <li><code>ParamInt</code> \u2014 An int parameter whose value is automatically casted into an int&lt;/&gt;</li> <li><code>ParamFloat</code> \u2014 A float parameter whose value is automatically casted into a float&lt;/&gt;</li> <li><code>ParamStr</code> \u2014 A str parameter whose value is automatically casted into a str&lt;/&gt;</li> <li><code>ParamBool</code> \u2014 A bool parameter whose value is automatically casted into a bool&lt;/&gt;</li> <li><code>ParamCount</code> \u2014 A bool parameter whose value is automatically casted into a bool&lt;/&gt;</li> <li><code>ParamPath</code> \u2014 A path parameter whose value is automatically casted into a pathlib.Path&lt;/&gt;</li> <li><code>ParamDir</code> \u2014 Subclass of ParamPath.&lt;/&gt;</li> <li><code>ParamPy</code> \u2014 A parameter whose value will be ast.literal_eval'ed&lt;/&gt;</li> <li><code>ParamJson</code> \u2014 A parameter whose value will be parsed as json&lt;/&gt;</li> <li><code>ParamList</code> \u2014 A parameter whose value is a list&lt;/&gt;</li> <li><code>ParamChoice</code> \u2014 A bool parameter whose value is automatically casted into a bool&lt;/&gt;</li> <li><code>ParamNamespace</code> \u2014 A pseudo parameter serving as a namespace for parameters under it&lt;/&gt;</li> <li><code>ParamNamespace</code> \u2014 A pseudo parameter serving as a namespace for parameters under it&lt;/&gt;</li> </ul> Functions <ul> <li><code>register_param</code><code>(</code><code>param</code><code>)</code> \u2014 Register a parameter class&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Classes for completions</p> <p>The idea is inspired from https://github.com/pallets/click/pull/1622</p> <p>Some of the code is borrowing there, under following LICENSE:</p> <p>Copyright 2014 Pallets</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p> Classes <ul> <li><code>Completer</code> \u2014 Main completion handler&lt;/&gt;</li> <li><code>CompleterParam</code> \u2014 Class for a parameter dealing with completion&lt;/&gt;</li> </ul> Functions <ul> <li><code>split_arg_string</code><code>(</code><code>string</code><code>)</code> (list of str) \u2014 Given an argument string this attempts to split it into small parts.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Utilities for pyparam</p> Attributes <ul> <li><code>logger</code> \u2014 The logger</li> </ul> Classes <ul> <li><code>Namespace</code> \u2014 Subclass of <code>argparse.Namespace</code>&lt;/&gt;</li> <li><code>Codeblock</code> \u2014 A code block, will be rendered as rich.syntax.Syntax&lt;/&gt;</li> <li><code>RichHandler</code> \u2014 Subclass of rich.logging.RichHandler, showing log levels as a single character&lt;/&gt;</li> </ul> Functions <ul> <li><code>always_list</code><code>(</code><code>str_or_list</code>, <code>strip</code>, <code>split</code><code>)</code> (list of str) \u2014 Convert a string (comma separated) or a list to a list&lt;/&gt;</li> <li><code>cast_to</code><code>(</code><code>value</code>, <code>to_type</code><code>)</code> (any) \u2014 Cast a value to a given type&lt;/&gt;</li> <li><code>parse_potential_argument</code><code>(</code><code>arg</code>, <code>prefix</code>, <code>allow_attached</code><code>)</code> (str, str, str) \u2014 Parse a potential argument with given prefix&lt;/&gt;</li> <li><code>parse_type</code><code>(</code><code>typestr</code><code>)</code> (list of str) \u2014 Parse the type string&lt;/&gt;</li> <li><code>type_from_value</code><code>(</code><code>value</code><code>)</code> (str) \u2014 Detect parameter type from a value&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Help assembler for pyparam</p> Attributes <ul> <li><code>THEMES</code> (dict(str: Theme)) \u2014 The theme for the help page.</li> </ul> Classes <ul> <li><code>ProgHighlighter</code> \u2014 Apply style to anything that looks like a program name.&lt;/&gt;</li> <li><code>OptnameHighlighter</code> \u2014 Apply style to anything that looks like a option name.&lt;/&gt;</li> <li><code>OpttypeHighlighter</code> \u2014 Apply style to anything that looks like a option type.&lt;/&gt;</li> <li><code>DefaultHighlighter</code> \u2014 Apply style to anything that looks like default value in option desc.&lt;/&gt;</li> <li><code>HelpSection</code> \u2014 Base class for all help sections.&lt;/&gt;</li> <li><code>HelpSectionPlain</code> \u2014 Plain text section&lt;/&gt;</li> <li><code>HelpSectionUsage</code> \u2014 Usage section in help&lt;/&gt;</li> <li><code>HelpSectionOption</code> \u2014 Options section in help&lt;/&gt;</li> <li><code>HelpAssembler</code> \u2014 Assemble a help page&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Definition of Params</p> Classes <ul> <li><code>Params</code> \u2014 Params, served as root params or subcommands&lt;/&gt;</li> </ul>"},{"location":"api/pyparam/#pyparam","title":"pyparam","text":""},{"location":"api/pyparam/#pyparamdefaults","title":"pyparam.defaults","text":""},{"location":"api/pyparam/#pyparamexceptions","title":"pyparam.exceptions","text":""},{"location":"api/pyparam/#pyparamparam","title":"pyparam.param","text":""},{"location":"api/pyparam/#pyparamcompleter","title":"pyparam.completer","text":""},{"location":"api/pyparam/#pyparamutils","title":"pyparam.utils","text":""},{"location":"api/pyparam/#pyparamhelp","title":"pyparam.help","text":""},{"location":"api/pyparam/#pyparamparams","title":"pyparam.params","text":""},{"location":"api/pyparam.param/","title":"pyparam.param","text":"module &lt;/&gt; <p>Definition of a single parameter</p> Attributes <ul> <li><code>PARAM_MAPPINGS</code> (dict(str: type of Param)) \u2014 The type to Param mappings, used for params to init a parameter. Managed by <code>register_param</code></li> </ul> Classes <ul> <li><code>Param</code> \u2014 Base class for parameter&lt;/&gt;</li> <li><code>ParamAuto</code> \u2014 An auto parameter whose value is automatically casted&lt;/&gt;</li> <li><code>ParamInt</code> \u2014 An int parameter whose value is automatically casted into an int&lt;/&gt;</li> <li><code>ParamFloat</code> \u2014 A float parameter whose value is automatically casted into a float&lt;/&gt;</li> <li><code>ParamStr</code> \u2014 A str parameter whose value is automatically casted into a str&lt;/&gt;</li> <li><code>ParamBool</code> \u2014 A bool parameter whose value is automatically casted into a bool&lt;/&gt;</li> <li><code>ParamCount</code> \u2014 A bool parameter whose value is automatically casted into a bool&lt;/&gt;</li> <li><code>ParamPath</code> \u2014 A path parameter whose value is automatically casted into a pathlib.Path&lt;/&gt;</li> <li><code>ParamDir</code> \u2014 Subclass of ParamPath.&lt;/&gt;</li> <li><code>ParamPy</code> \u2014 A parameter whose value will be ast.literal_eval'ed&lt;/&gt;</li> <li><code>ParamJson</code> \u2014 A parameter whose value will be parsed as json&lt;/&gt;</li> <li><code>ParamList</code> \u2014 A parameter whose value is a list&lt;/&gt;</li> <li><code>ParamChoice</code> \u2014 A bool parameter whose value is automatically casted into a bool&lt;/&gt;</li> <li><code>ParamNamespace</code> \u2014 A pseudo parameter serving as a namespace for parameters under it&lt;/&gt;</li> <li><code>ParamNamespace</code> \u2014 A pseudo parameter serving as a namespace for parameters under it&lt;/&gt;</li> </ul> Functions <ul> <li><code>register_param</code><code>(</code><code>param</code><code>)</code> \u2014 Register a parameter class&lt;/&gt;</li> </ul> class &lt;/&gt; Bases pyparam.completer.CompleterParam <p>Base class for parameter</p> Parameters <ul> <li><code>names</code> (Union(str, list of str)) \u2014 The names of the parameter</li> <li><code>default</code> (any) \u2014 The default value</li> <li><code>desc</code> (list of str) \u2014 The description of the parameter</li> <li><code>prefix</code> (str, optional) \u2014 The prefix of the parameter on the command line</li> <li><code>show</code> (bool, optional) \u2014 Whether this parameter should show on help page</li> <li><code>required</code> (bool, optional) \u2014 Whether this parameter is required</li> <li><code>subtype</code> (str or bool, optional) \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool, optional) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>callback</code> (callable, optional) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable, optional) \u2014 The callback for complete the values of the parameter</li> <li><code>argname_shorten</code> (bool, optional) \u2014 Whether show shortened name for parameters under namespace parameters</li> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Parameters <ul> <li><code>Value</code> \u2014 value to consume</li> </ul> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>An auto parameter whose value is automatically casted</p> Parameters <ul> <li><code>names</code> (Union(str, list of str)) \u2014 The names of the parameter</li> <li><code>default</code> (any) \u2014 The default value</li> <li><code>desc</code> (list of str) \u2014 The description of the parameter</li> <li><code>prefix</code> (str, optional) \u2014 The prefix of the parameter on the command line</li> <li><code>show</code> (bool, optional) \u2014 Whether this parameter should show on help page</li> <li><code>required</code> (bool, optional) \u2014 Whether this parameter is required</li> <li><code>subtype</code> (str or bool, optional) \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool, optional) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>callback</code> (callable, optional) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable, optional) \u2014 The callback for complete the values of the parameter</li> <li><code>argname_shorten</code> (bool, optional) \u2014 Whether show shortened name for parameters under namespace parameters</li> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>An int parameter whose value is automatically casted into an int</p> Parameters <ul> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A float parameter whose value is automatically casted into a float</p> Parameters <ul> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A str parameter whose value is automatically casted into a str</p> Parameters <ul> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A bool parameter whose value is automatically casted into a bool</p> Parameters <ul> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str), iterator of (str, str), iterator of (str, str, str))) \u2014 Get the completion candidates for the current parameter&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Should I consume given value?&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Should I consume given value?</p> method &lt;/&gt; <p>Get the completion candidates for the current parameter</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A bool parameter whose value is automatically casted into a bool</p> Parameters <ul> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (str, str) \u2014 Complete names for a count parameter&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Should I consume given parameter?&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Should I consume given parameter?</p> generator &lt;/&gt; <p>Complete names for a count parameter</p> <p>Since we have -v, -vv, -vvv allowed for a count parameter, we need to put them in the completions, too.</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A path parameter whose value is automatically casted into a pathlib.Path</p> Parameters <ul> <li><code>names</code> (Union(str, list of str)) \u2014 The names of the parameter</li> <li><code>default</code> (any) \u2014 The default value</li> <li><code>desc</code> (list of str) \u2014 The description of the parameter</li> <li><code>prefix</code> (str, optional) \u2014 The prefix of the parameter on the command line</li> <li><code>show</code> (bool, optional) \u2014 Whether this parameter should show on help page</li> <li><code>required</code> (bool, optional) \u2014 Whether this parameter is required</li> <li><code>subtype</code> (str or bool, optional) \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool, optional) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>callback</code> (callable, optional) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable, optional) \u2014 The callback for complete the values of the parameter</li> <li><code>argname_shorten</code> (bool, optional) \u2014 Whether show shortened name for parameters under namespace parameters</li> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Generate file paths with given current prefix as completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> method &lt;/&gt; <p>Generate file paths with given current prefix as completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current word or prefix under cursor</li> </ul> class &lt;/&gt; Bases pyparam.param.ParamPath pyparam.param.Param pyparam.completer.CompleterParam <p>Subclass of ParamPath.</p> <p>It does not make any difference with pyparam. However, it works differently for completions. The completion items for this param will only give directories instead of all paths</p> Parameters <ul> <li><code>names</code> (Union(str, list of str)) \u2014 The names of the parameter</li> <li><code>default</code> (any) \u2014 The default value</li> <li><code>desc</code> (list of str) \u2014 The description of the parameter</li> <li><code>prefix</code> (str, optional) \u2014 The prefix of the parameter on the command line</li> <li><code>show</code> (bool, optional) \u2014 Whether this parameter should show on help page</li> <li><code>required</code> (bool, optional) \u2014 Whether this parameter is required</li> <li><code>subtype</code> (str or bool, optional) \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool, optional) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>callback</code> (callable, optional) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable, optional) \u2014 The callback for complete the values of the parameter</li> <li><code>argname_shorten</code> (bool, optional) \u2014 Whether show shortened name for parameters under namespace parameters</li> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Generate dir paths with given current prefix as completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> method &lt;/&gt; <p>Generate dir paths with given current prefix as completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current word or prefix under cursor</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A parameter whose value will be ast.literal_eval'ed</p> Parameters <ul> <li><code>names</code> (Union(str, list of str)) \u2014 The names of the parameter</li> <li><code>default</code> (any) \u2014 The default value</li> <li><code>desc</code> (list of str) \u2014 The description of the parameter</li> <li><code>prefix</code> (str, optional) \u2014 The prefix of the parameter on the command line</li> <li><code>show</code> (bool, optional) \u2014 Whether this parameter should show on help page</li> <li><code>required</code> (bool, optional) \u2014 Whether this parameter is required</li> <li><code>subtype</code> (str or bool, optional) \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool, optional) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>callback</code> (callable, optional) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable, optional) \u2014 The callback for complete the values of the parameter</li> <li><code>argname_shorten</code> (bool, optional) \u2014 Whether show shortened name for parameters under namespace parameters</li> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A parameter whose value will be parsed as json</p> Parameters <ul> <li><code>names</code> (Union(str, list of str)) \u2014 The names of the parameter</li> <li><code>default</code> (any) \u2014 The default value</li> <li><code>desc</code> (list of str) \u2014 The description of the parameter</li> <li><code>prefix</code> (str, optional) \u2014 The prefix of the parameter on the command line</li> <li><code>show</code> (bool, optional) \u2014 Whether this parameter should show on help page</li> <li><code>required</code> (bool, optional) \u2014 Whether this parameter is required</li> <li><code>subtype</code> (str or bool, optional) \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool, optional) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>callback</code> (callable, optional) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable, optional) \u2014 The callback for complete the values of the parameter</li> <li><code>argname_shorten</code> (bool, optional) \u2014 Whether show shortened name for parameters under namespace parameters</li> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A parameter whose value is a list</p> Parameters <ul> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Should I consume given parameter?&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Also register reset type&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Deal with when param_type is reset&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> classmethod &lt;/&gt; <p>Also register reset type</p> method &lt;/&gt; <p>Deal with when param_type is reset</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> method &lt;/&gt; <p>Should I consume given parameter?</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A bool parameter whose value is automatically casted into a bool</p> Parameters <ul> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> \u2014 If default is not specified in desc, just to add with the default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Generate choices with given current prefix as completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Consume a value&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code><code>)</code> \u2014 Push a value into the stack for calculating&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Consume a value</p> Returns (bool) <p>True if value was consumed, otherwise False</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Push a value into the stack for calculating</p> Returns <p>The item to be pushed</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> method &lt;/&gt; <p>Generate choices with given current prefix as completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current word or prefix under cursor</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A pseudo parameter serving as a namespace for parameters under it</p> <p>So that it is possible to do: <pre><code>prog --namespace.arg1 1 --namespace.arg2 2\n</code></pre></p> Parameters <ul> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> (str) \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> (list of str) \u2014 Namespace parameters do not have a default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Should I consume given parameter?&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>decendents</code><code>(</code><code>show_only</code><code>)</code> (list of Param) \u2014 Get all decendents of this namespace parameter&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>get_param</code><code>(</code><code>name</code>, <code>depth</code><code>)</code> (Param) \u2014 Get the paraemeter by given name&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code>, <code>depth</code><code>)</code> \u2014 Push the parameter under this namespace.&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Get all decendents of this namespace parameter</p> Parameters <ul> <li><code>show_only</code> (optional) \u2014 Load params with show=True only?</li> </ul> Returns (list of Param) <p>The decendents of this namespace parameter</p> method &lt;/&gt; <p>Should I consume given parameter?</p> method &lt;/&gt; <p>Get the paraemeter by given name</p> <p>This parameter is like '-a', and the name can be 'a.b.c.d'</p> Parameters <ul> <li><code>name</code> (str) \u2014 The name of the parameter to get</li> <li><code>depth</code> (int, optional) \u2014 The depth</li> </ul> Returns (Param) <p>The parameter we get with the given name</p> method &lt;/&gt; <p>Push the parameter under this namespace.</p> <p>We are not pushing any values to this namespace, but pushing parameters that are under it.</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> class &lt;/&gt; Bases pyparam.param.Param pyparam.completer.CompleterParam <p>A pseudo parameter serving as a namespace for parameters under it</p> <p>So that it is possible to do: <pre><code>prog --namespace.arg1 1 --namespace.arg2 2\n</code></pre></p> Parameters <ul> <li><code>**kwargs</code> (dict(str: any)) \u2014 Additional keyword arguments</li> </ul> Attributes <ul> <li><code>_desc</code> (list of str) \u2014 The raw description of the parameter</li> <li><code>_kwargs</code> (dict(str: any)) \u2014 other kwargs</li> <li><code>_stack</code> (list of any) \u2014 The stack to push the values</li> <li><code>_value_cached</code> (any) \u2014 The cached value calculated from the stack</li> <li><code>argname_shorten</code> (bool) \u2014 Whether show shortened name for the parameters under namespace parameters</li> <li><code>callback</code> (callable) \u2014 The callback to modify the final value</li> <li><code>complete_callback</code> (callable) \u2014 The callback for complete the values of the parameter</li> <li><code>default</code> \u2014 The default value</li> <li><code>default_group</code> (str) \u2014 Get the default group of the parameter&lt;/&gt;</li> <li><code>desc</code> (list of str) \u2014 The formatted description using attributes and _kwargs&lt;/&gt;</li> <li><code>desc_with_default</code> (list of str) \u2014 Namespace parameters do not have a default value&lt;/&gt;</li> <li><code>hit</code> (bool) \u2014 Whether the parameter is just hit</li> <li><code>is_help</code> (bool) \u2014 Whether this is a help parameter</li> <li><code>is_positional</code> \u2014 Tell if this parameter is positional&lt;/&gt;</li> <li><code>names</code> \u2014 The names of the parameter</li> <li><code>ns_param</code> (ParamNamespace) \u2014 The namespace parameter where this parameter is under</li> <li><code>prefix</code> (str) \u2014 The prefix of the parameter on the command line</li> <li><code>required</code> (bool) \u2014 Whether this parameter is required</li> <li><code>show</code> (bool) \u2014 Whether this parameter should show on help page</li> <li><code>subtype</code> \u2014 The subtype of the parameter if this is a complex type</li> <li><code>type_frozen</code> (bool) \u2014 Whether the type is frozen (not allowing overwritting from command line)</li> <li><code>value</code> \u2014 Return the cached value if possible, otherwise calcuate one&lt;/&gt;</li> </ul> Methods <ul> <li><code>apply_callback</code><code>(</code><code>all_values</code><code>)</code> (any) \u2014 Apply the callback function to the value&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Close up the parameter while scanning the command line&lt;/&gt;</li> <li><code>complete_name</code><code>(</code><code>current</code><code>)</code> (iterator of (str, str)) \u2014 Give the completion name candidates&lt;/&gt;</li> <li><code>complete_value</code><code>(</code><code>current</code>, <code>prefix</code><code>)</code> (Union(str, iterator of (str, ...))) \u2014 Give the completion candidates&lt;/&gt;</li> <li><code>consume</code><code>(</code><code>value</code><code>)</code> (bool) \u2014 Should I consume given parameter?&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>)</code> (Param) \u2014 Copy a parameter so that it can be reused.&lt;/&gt;</li> <li><code>decendents</code><code>(</code><code>show_only</code><code>)</code> (list of Param) \u2014 Get all decendents of this namespace parameter&lt;/&gt;</li> <li><code>full_names</code><code>(</code><code>)</code> (list of str) \u2014 make the names with full combinations of namespaces and terminals&lt;/&gt;</li> <li><code>get_param</code><code>(</code><code>name</code>, <code>depth</code><code>)</code> (Param) \u2014 Get the paraemeter by given name&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namespaces</code><code>(</code><code>index</code><code>)</code> (Union(list of str, int)) \u2014 Get the namespaces at the given index or number of namespaces&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code>, <code>with_prefix</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>on_register</code><code>(</code><code>)</code> \u2014 Opens opportunity to do something when a parameter is registered&lt;/&gt;</li> <li><code>optstr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter names and types in the optname section in help page&lt;/&gt;</li> <li><code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> (Param) \u2014 Try to overwrite the type&lt;/&gt;</li> <li><code>push</code><code>(</code><code>item</code>, <code>depth</code><code>)</code> \u2014 Push the parameter under this namespace.&lt;/&gt;</li> <li><code>to</code><code>(</code><code>to_type</code><code>)</code> (Param) \u2014 Generate a different type of parameter using current settings&lt;/&gt;</li> <li><code>typestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the type&lt;/&gt;</li> <li><code>usagestr</code><code>(</code><code>)</code> (str) \u2014 Get the string representation of the parameter in the default usage constructor&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Give the completion candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 Current prefix</li> </ul> Returns (Union(str, iterator of (str, ...))) <p>None when there are no candidates, nor should we have next     paramters/commands as candidates (requiring a value).     An empty string if we should put next parameters/commands     as candidates. Otherwise yields     The candidates should be either 1-, 2-, or 3-element tuple.     If 1-element, type plain and no description implied.     If 2-element, type plain and 2nd element should be description.     If 3-element, 2nd element the type, 3rd the description.</p> generator &lt;/&gt; <p>Give the completion name candidates</p> Parameters <ul> <li><code>current</code> (str) \u2014 The current prefix or word under cursor</li> </ul> Returns (iterator of (str, str)) <p>An iterator of a tuple including the prefixed name and description.</p> classmethod &lt;/&gt; <p>Opens opportunity to do something when a parameter is registered</p> method &lt;/&gt; <p>Get the namespaces at the given index or number of namespaces</p> Parameters <ul> <li><code>index</code> (int or str, optional) \u2014 The index or a length indicator</li> </ul> Returns (Union(list of str, int)) <p>The length of the namespaces or the namespaces at index.</p> method &lt;/&gt; <p>make the names with full combinations of namespaces and terminals</p> <p>Since one can define a parameter like <code>n.arg</code> but namespace <code>n</code> can have aliases (i.e. <code>ns</code>). This makes sure the names of <code>n.arg</code> expands to <code>n.arg</code> and <code>ns.arg</code></p> Returns (list of str) <p>The names with full combinations of namespaces and terminals</p> method &lt;/&gt; <p>Close up the parameter while scanning the command line</p> <p>We are mostly doing nothing, only if, say, param is bool and it was just hit, we should push a true value to it.</p> method &lt;/&gt; <p>Try to overwrite the type</p> <p>Only when param_type is not None and it's different from mine A new param will be returned if different</p> Parameters <ul> <li><code>param_type</code> (str) \u2014 The type to overwrite</li> </ul> Returns (Param) <p>Self when type not changed otherwise a new parameter with     the given type</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> <li><code>with_prefix</code> (bool, optional) \u2014 Whether to include the prefix or not</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the string representation of the type</p> Returns (str) <p>the string representation of the type</p> method &lt;/&gt; <p>Get the string representation of the parameter in the default usage constructor</p> Returns (str) <p>the string representation of the parameter in the default usage</p> method &lt;/&gt; <p>Get the string representation of the parameter names and types in the optname section in help page</p> Returns (str) <p>the string representation of the parameter names and types     in the optname section in help page</p> method &lt;/&gt; <p>Generate a different type of parameter using current settings</p> Parameters <ul> <li><code>to_type</code> (str) \u2014 the type of parameter to generate</li> </ul> Returns (Param) <p>the generated parameter with different type</p> method &lt;/&gt; <p>Get all decendents of this namespace parameter</p> Parameters <ul> <li><code>show_only</code> (optional) \u2014 Load params with show=True only?</li> </ul> Returns (list of Param) <p>The decendents of this namespace parameter</p> method &lt;/&gt; <p>Should I consume given parameter?</p> method &lt;/&gt; <p>Get the paraemeter by given name</p> <p>This parameter is like '-a', and the name can be 'a.b.c.d'</p> Parameters <ul> <li><code>name</code> (str) \u2014 The name of the parameter to get</li> <li><code>depth</code> (int, optional) \u2014 The depth</li> </ul> Returns (Param) <p>The parameter we get with the given name</p> method &lt;/&gt; <p>Push the parameter under this namespace.</p> <p>We are not pushing any values to this namespace, but pushing parameters that are under it.</p> method &lt;/&gt; <p>Copy a parameter so that it can be reused.</p> Returns (Param) <p>The copy of the parameter</p> method &lt;/&gt; <p>Apply the callback function to the value</p> Parameters <ul> <li><code>all_values</code> (Namespace) \u2014 The namespace of values of all parameters</li> </ul> Returns (any) <p>The value after the callback applied</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When exceptions raised or returned from callback</li> </ul> function &lt;/&gt; <p>Register a parameter class</p> Parameters <ul> <li><code>param</code> (type of Param) \u2014 The param to register A param class should include a type You can also define type alias for a param type</li> </ul>"},{"location":"api/pyparam.param/#pyparamparam","title":"pyparam.param","text":""},{"location":"api/pyparam.param/#pyparamparamparam","title":"<code>pyparam.param.</code><code>Param</code><code>(</code><code>names</code>, <code>default</code>, <code>desc</code>, <code>prefix='auto'</code>, <code>show=True</code>, <code>required=False</code>, <code>subtype=None</code>, <code>type_frozen=True</code>, <code>callback=None</code>, <code>complete_callback=None</code>, <code>argname_shorten=True</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamauto","title":"<code>pyparam.param.</code><code>ParamAuto</code><code>(</code><code>names</code>, <code>default</code>, <code>desc</code>, <code>prefix='auto'</code>, <code>show=True</code>, <code>required=False</code>, <code>subtype=None</code>, <code>type_frozen=True</code>, <code>callback=None</code>, <code>complete_callback=None</code>, <code>argname_shorten=True</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_1","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_1","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_1","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_1","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_1","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_1","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_1","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume_1","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_1","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_1","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_1","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_1","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_1","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_1","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_1","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_1","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_1","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamint","title":"<code>pyparam.param.</code><code>ParamInt</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_2","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_2","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_2","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_2","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_2","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_2","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_2","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume_2","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_2","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_2","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_2","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_2","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_2","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_2","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_2","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_2","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_2","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfloat","title":"<code>pyparam.param.</code><code>ParamFloat</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_3","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_3","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_3","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_3","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_3","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_3","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_3","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume_3","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_3","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_3","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_3","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_3","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_3","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_3","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_3","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_3","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_3","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamstr","title":"<code>pyparam.param.</code><code>ParamStr</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_4","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_4","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_4","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_4","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_4","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_4","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_4","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume_4","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_4","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_4","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_4","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_4","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_4","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_4","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_4","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_4","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_4","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparambool","title":"<code>pyparam.param.</code><code>ParamBool</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_5","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_5","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_5","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_5","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_5","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_5","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_5","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_5","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_5","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_5","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_5","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_5","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamboolusagestr","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparambooloptstr","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamboolclose","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamboolconsume","title":"<code>consume</code><code>(</code><code>value</code><code>)</code> \u2192 bool","text":""},{"location":"api/pyparam.param/#pyparamparamparamboolcomplete_value","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code> \u2192 Union(str, iterator of (str), iterator of (str, str), iterator of (str, str, str))","text":""},{"location":"api/pyparam.param/#pyparamparamparamcount","title":"<code>pyparam.param.</code><code>ParamCount</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_5","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_6","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_6","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_6","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_6","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_6","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_6","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_6","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_5","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_5","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_6","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_6","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_6","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_6","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcountclose","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcountconsume","title":"<code>consume</code><code>(</code><code>value</code><code>)</code> \u2192 bool","text":""},{"location":"api/pyparam.param/#pyparamparamparamcountcomplete_name","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code> \u2192 (str, str)","text":""},{"location":"api/pyparam.param/#pyparamparamparampath","title":"<code>pyparam.param.</code><code>ParamPath</code><code>(</code><code>names</code>, <code>default</code>, <code>desc</code>, <code>prefix='auto'</code>, <code>show=True</code>, <code>required=False</code>, <code>subtype=None</code>, <code>type_frozen=True</code>, <code>callback=None</code>, <code>complete_callback=None</code>, <code>argname_shorten=True</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_6","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_7","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_7","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_7","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_5","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_7","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume_5","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_7","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_7","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_7","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_6","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_6","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_7","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_7","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_7","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_7","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampathcomplete_value","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code> \u2192 Union(str, iterator of (str, ...))","text":""},{"location":"api/pyparam.param/#pyparamparamparamdir","title":"<code>pyparam.param.</code><code>ParamDir</code><code>(</code><code>names</code>, <code>default</code>, <code>desc</code>, <code>prefix='auto'</code>, <code>show=True</code>, <code>required=False</code>, <code>subtype=None</code>, <code>type_frozen=True</code>, <code>callback=None</code>, <code>complete_callback=None</code>, <code>argname_shorten=True</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_7","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_8","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_8","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_8","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_6","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_8","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume_6","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_8","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_8","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_8","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_7","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_7","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_8","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_8","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_8","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_8","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamdircomplete_value","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code> \u2192 Union(str, iterator of (str, ...))","text":""},{"location":"api/pyparam.param/#pyparamparamparampy","title":"<code>pyparam.param.</code><code>ParamPy</code><code>(</code><code>names</code>, <code>default</code>, <code>desc</code>, <code>prefix='auto'</code>, <code>show=True</code>, <code>required=False</code>, <code>subtype=None</code>, <code>type_frozen=True</code>, <code>callback=None</code>, <code>complete_callback=None</code>, <code>argname_shorten=True</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_6","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_8","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_9","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_9","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_9","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_7","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_9","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume_7","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_9","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_9","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_9","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_8","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_8","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_9","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_9","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_9","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_9","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamjson","title":"<code>pyparam.param.</code><code>ParamJson</code><code>(</code><code>names</code>, <code>default</code>, <code>desc</code>, <code>prefix='auto'</code>, <code>show=True</code>, <code>required=False</code>, <code>subtype=None</code>, <code>type_frozen=True</code>, <code>callback=None</code>, <code>complete_callback=None</code>, <code>argname_shorten=True</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_7","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_9","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_10","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_10","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_10","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_8","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_10","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume_8","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_10","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_10","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_10","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_9","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_9","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_10","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_10","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_10","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_10","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamlist","title":"<code>pyparam.param.</code><code>ParamList</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_8","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_10","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_11","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_11","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_9","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_11","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_11","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_11","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_10","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_10","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_11","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_11","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_11","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamliston_register","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamlistoverwrite_type","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code> \u2192 Param","text":""},{"location":"api/pyparam.param/#pyparamparamparamlistconsume","title":"<code>consume</code><code>(</code><code>value</code><code>)</code> \u2192 bool","text":""},{"location":"api/pyparam.param/#pyparamparamparamlistpush","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamchoice","title":"<code>pyparam.param.</code><code>ParamChoice</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_11","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_11","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_12","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_12","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_10","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_11","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamconsume_9","title":"<code>consume</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_12","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_12","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_12","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_11","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_11","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_12","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamcopy_12","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparampush_11","title":"<code>push</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamapply_callback_12","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamchoicecomplete_value","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code> \u2192 Union(str, iterator of (str, ...))","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespace","title":"<code>pyparam.param.</code><code>ParamNamespace</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_9","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_12","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_12","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_13","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_13","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_11","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_12","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_13","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_13","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_13","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_12","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_12","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_13","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespacedecendents","title":"<code>decendents</code><code>(</code><code>show_only=False</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaceconsume","title":"<code>consume</code><code>(</code><code>value</code><code>)</code> \u2192 bool","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaceget_param","title":"<code>get_param</code><code>(</code><code>name</code>, <code>depth=0</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespacepush","title":"<code>push</code><code>(</code><code>item</code>, <code>depth=0</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespacecopy","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaceapply_callback","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespace_1","title":"<code>pyparam.param.</code><code>ParamNamespace</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_value_10","title":"<code>complete_value</code><code>(</code><code>current</code>, <code>prefix=''</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamcompletercompleterparamcomplete_name_13","title":"<code>complete_name</code><code>(</code><code>current</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamon_register_13","title":"<code>on_register</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaces_14","title":"<code>namespaces</code><code>(</code><code>index='len'</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamfull_names_14","title":"<code>full_names</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamclose_12","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoverwrite_type_13","title":"<code>overwrite_type</code><code>(</code><code>param_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamname_14","title":"<code>name</code><code>(</code><code>which</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamestr_14","title":"<code>namestr</code><code>(</code><code>sep=', '</code>, <code>with_prefix=True</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamtypestr_14","title":"<code>typestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamusagestr_13","title":"<code>usagestr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamoptstr_13","title":"<code>optstr</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamto_14","title":"<code>to</code><code>(</code><code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespacedecendents_1","title":"<code>decendents</code><code>(</code><code>show_only=False</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaceconsume_1","title":"<code>consume</code><code>(</code><code>value</code><code>)</code> \u2192 bool","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaceget_param_1","title":"<code>get_param</code><code>(</code><code>name</code>, <code>depth=0</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespacepush_1","title":"<code>push</code><code>(</code><code>item</code>, <code>depth=0</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespacecopy_1","title":"<code>copy</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamparamnamespaceapply_callback_1","title":"<code>apply_callback</code><code>(</code><code>all_values</code><code>)</code>","text":""},{"location":"api/pyparam.param/#pyparamparamregister_param","title":"<code>pyparam.param.</code><code>register_param</code><code>(</code><code>param</code><code>)</code>","text":""},{"location":"api/pyparam.params/","title":"pyparam.params","text":"module &lt;/&gt; <p>Definition of Params</p> Classes <ul> <li><code>Params</code> \u2014 Params, served as root params or subcommands&lt;/&gt;</li> </ul> class &lt;/&gt; Bases pyparam.completer.Completer <p>Params, served as root params or subcommands</p> Parameters <ul> <li><code>names</code> (Union(str, list of str), optional) \u2014 The names of this command if served as a command</li> <li><code>desc</code> (Union(list of str, str), optional) \u2014 The description of the command. This will be finally compiled into a list if a string is given. The difference is, when displayed on help page, the string will be wrapped by textwrap automatically. However, each element in a given list will not be wrapped.</li> <li><code>prog</code> (str, optional) \u2014 The program name</li> <li><code>help_keys</code> (Union(str, list of str), optional) \u2014 The names to bring up the help information</li> <li><code>help_cmds</code> (Union(str, list of str), optional) \u2014 The help command names to show help of other subcommands</li> <li><code>help_on_void</code> (str or bool, optional) \u2014 Whether to show help when no arguments provided</li> <li><code>help_callback</code> (callable, optional) \u2014 A function to modify the help page</li> <li><code>help_modifier</code> (callable, optional) \u2014 A callback function to modify the help param/command</li> <li><code>prefix</code> (str, optional) \u2014 The prefix for the arguments (see attribute <code>Params.prefix</code>)</li> <li><code>arbitrary</code> (str or bool, optional) \u2014 Whether to parse the command line arbitrarily</li> <li><code>theme</code> (str|rich.theme.Theme) \u2014 The theme to render the help page</li> <li><code>usage</code> (Union(str, list of str), optional) \u2014 Some example usages</li> </ul> Attributes <ul> <li><code>arbitrary</code> \u2014 Whether parsing the command line arbitrarily</li> <li><code>asssembler</code> \u2014 The asssembler to assemble the help page</li> <li><code>command_groups</code> \u2014 The ordered dict of command groups</li> <li><code>commands</code> \u2014 The ordered dict of registered commands</li> <li><code>comp_curr</code> (str) \u2014 The current word for completion</li> <li><code>comp_prev</code> (str) \u2014 The previous word matched</li> <li><code>comp_shell</code> (str) \u2014 The shell where the completion will be conducted One of ['', 'bash', 'fish', 'zsh'] Obtained from environment</li> <li><code>comp_words</code> (list of str) \u2014 The words have been entered before completion</li> <li><code>desc</code> (list of str) \u2014 The description of the command.</li> <li><code>help_cmds</code> (list of str) \u2014 The names of help subcommands to bring up help information of subcommands</li> <li><code>help_keys</code> (list of str) \u2014 The names to bring up the help information.</li> <li><code>help_on_void</code> (bool) \u2014 Whether show help when there is not arguments provided</li> <li><code>names</code> (list of str) \u2014 The names of the commands if this serves as sub-command</li> <li><code>param_groups</code> \u2014 The ordered dict of parameter groups</li> <li><code>params</code> \u2014 The ordered dict of registered parameters</li> <li><code>prefix</code> \u2014 The prefix for the arguments on command line - <code>auto</code>: Automatically determine the prefix for each argument.     Basically, <code>-</code> for short options, and <code>--</code> for long.     Note that <code>-</code> for <code>-vvv</code> if <code>v</code> is a count option</li> <li><code>prog</code> \u2014 The program name. Default: <code>sys.argv[0]</code></li> <li><code>prog</code> (str) \u2014 Get the program name&lt;/&gt;</li> <li><code>progvar</code> (str) \u2014 Get the program name that can be used as a variable&lt;/&gt;</li> <li><code>theme</code> (rich.theme.Theme|str) \u2014 The theme for the help page</li> <li><code>uid</code> (str) \u2014 Get the uid based on the raw program name This is used as the prefix or suffix of some shell function names&lt;/&gt;</li> <li><code>usage</code> \u2014 The usages of this program</li> </ul> Methods <ul> <li><code>add_command</code><code>(</code><code>names</code>, <code>desc</code>, <code>help_keys</code>, <code>help_cmds</code>, <code>help_on_void</code>, <code>help_callback</code>, <code>help_modifier</code>, <code>prefix</code>, <code>arbitrary</code>, <code>theme</code>, <code>usage</code>, <code>group</code>, <code>force</code><code>)</code> (Params) \u2014 Add a sub-command&lt;/&gt;</li> <li><code>add_param</code><code>(</code><code>names</code>, <code>default</code>, <code>type</code>, <code>desc</code>, <code>show</code>, <code>required</code>, <code>callback</code>, <code>group</code>, <code>force</code>, <code>type_frozen</code>, <code>argname_shorten</code>, <code>complete_callback</code>, <code>**kwargs</code><code>)</code> (Param) \u2014 Add an argument&lt;/&gt;</li> <li><code>complete</code><code>(</code><code>)</code> (str) \u2014 Yields the completions&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>deep</code><code>)</code> (Params) \u2014 Copy a Params object&lt;/&gt;</li> <li><code>from_arg</code><code>(</code><code>names</code>, <code>desc</code>, <code>group</code>, <code>default</code>, <code>show</code>, <code>force</code>, <code>args</code><code>)</code> \u2014 Load parameters from the file specified by naargument from command line&lt;/&gt;</li> <li><code>from_dict</code><code>(</code><code>dict_obj</code>, <code>show</code>, <code>force</code><code>)</code> \u2014 Load parameters from python dict&lt;/&gt;</li> <li><code>from_file</code><code>(</code><code>filename</code>, <code>show</code>, <code>force</code><code>)</code> \u2014 Load parameters from file&lt;/&gt;</li> <li><code>get_command</code><code>(</code><code>name</code><code>)</code> (Params) \u2014 Get the command object&lt;/&gt;</li> <li><code>get_param</code><code>(</code><code>name</code><code>)</code> (Param) \u2014 Get the parameter by name&lt;/&gt;</li> <li><code>name</code><code>(</code><code>which</code><code>)</code> (str) \u2014 Get the shortest/longest name of the parameter&lt;/&gt;</li> <li><code>namestr</code><code>(</code><code>sep</code><code>)</code> (str) \u2014 Get all names connected with a separator.&lt;/&gt;</li> <li><code>parse</code><code>(</code><code>args</code>, <code>ignore_errors</code><code>)</code> (Namespace) \u2014 Parse the arguments from the command line&lt;/&gt;</li> <li><code>print_help</code><code>(</code><code>exit_code</code>, <code>full</code><code>)</code> \u2014 Print the help information and exit&lt;/&gt;</li> <li><code>shellcode</code><code>(</code><code>shell</code>, <code>python</code>, <code>module</code><code>)</code> (str) \u2014 Generate the shell code to be integrated&lt;/&gt;</li> <li><code>to_dict</code><code>(</code><code>)</code> (Diot) \u2014 Save the parameters/commands to file.&lt;/&gt;</li> <li><code>to_file</code><code>(</code><code>path</code>, <code>cfgtype</code><code>)</code> \u2014 Save the parameters/commands to file.&lt;/&gt;</li> <li><code>values</code><code>(</code><code>namespace</code>, <code>ignore_errors</code><code>)</code> (Namespace) \u2014 Get a namespace of all parameter name =&gt; value pairs or attach them to the given namespace&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Generate the shell code to be integrated</p> <p>For bash, it should be appended to ~/.profile For zsh, it should be appended to ~/.zprofile For fish, it should be appended to     ~/.config/fish/completions/%(prog)s.fish     If python is provided, this should go to <code>python.fish</code> rather than     the <code>%(prog)s.fish</code></p> Parameters <ul> <li><code>shell</code> (str) \u2014 The shell to generate the code for.</li> <li><code>python</code> (str, optional) \u2014 The python name or path to invoke completion.</li> <li><code>module</code> (bool, optional) \u2014 Whether do completion for <code>python -m &lt;prog&gt;</code></li> </ul> Raises <ul> <li><code>ValueError</code> \u2014 if shell is not one of bash, zsh and fish</li> </ul> generator &lt;/&gt; <p>Yields the completions</p> Yields (str) <p>The strings as completion candidates</p> method &lt;/&gt; <p>Get the shortest/longest name of the parameter</p> <p>A name is ensured to be returned. It does not mean it is the real short/long name, but just the shortest/longest name among all the names</p> Parameters <ul> <li><code>which</code> (str, optional) \u2014 Whether get the shortest or longest name Could use <code>short</code> or <code>long</code> for short.</li> </ul> Returns (str) <p>The shortest/longest name of the parameter</p> method &lt;/&gt; <p>Get all names connected with a separator.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 The separator to connect the names</li> </ul> Returns (str) <p>the connected names</p> method &lt;/&gt; <p>Get the parameter by name</p> <p>If the parameter is under a namespace, try to get it via the namespace</p> Parameters <ul> <li><code>name</code> (str) \u2014 The name of the parameter to get (without prefix)</li> </ul> Returns (Param) <p>The parameter, None if failed</p> method &lt;/&gt; <p>Get the command object</p> Parameters <ul> <li><code>name</code> (str) \u2014 The name of the command to get</li> </ul> Returns (Params) <p>The command object, None if failed.</p> method &lt;/&gt; <p>Add an argument</p> Parameters <ul> <li><code>names</code> (Union(str, list of str, param)) \u2014 names of the argument or a parameter defined somewhere else For example, in case we want to reuse a parameter <pre><code>param = cmd1.add_param('n,name')\n# reuse it:\ncmd2.add_param(param)\n# other arguments will be ignored, except force\n</code></pre></li> <li><code>default</code> (any, optional) \u2014 The default value for the argument</li> <li><code>type</code> (str or type, optional) \u2014 The type of the argument Including single value type and complex one - Single value types:     auto, int, str, float, bool, count, py, json, reset - Complex value types:     list[], ns <li><code>desc</code> (Union(str, list of str), optional) \u2014 The description of the argument This will be finally compiled into a list if a string is given. The difference is, when displayed on help page, the string will be wrapped by textwrap automatically. However, each element in a given list will not be wrapped.</li> <li><code>show</code> (bool, optional) \u2014 Whether this should be shown on help page.</li> <li><code>required</code> (bool, optional) \u2014 Whether this argument is required from the command line</li> <li><code>callback</code> (callable, optional) \u2014 Callback to convert parsed values</li> <li><code>group</code> (str, optional) \u2014 The group this parameter belongs to. Arguments will be grouped by this on the help page.</li> <li><code>force</code> (bool, optional) \u2014 Whether to force adding parameter if it exists</li> <li><code>type_frozen</code> (bool, optional) \u2014 Whether allow type overwritting from the commone line</li> <li><code>argname_shorten</code> (bool, optional) \u2014 Whether show shortened name for parameter under namespace parameter</li> <li><code>complete_callback</code> (callable, optional) \u2014 The callback for complete the values of the parameter</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments</li> Raises <ul> <li><code>PyParamNameError</code> \u2014 When parameter exists and force is false</li> </ul> <p>Return:     Param: The added parameter</p> method &lt;/&gt; <p>Add a sub-command</p> Parameters <ul> <li><code>names</code> (Union(params, str, list of str)) \u2014 list of names of this command It can also be a Params object that served as a subcommand</li> <li><code>desc</code> (Union(str, list of str), optional) \u2014 description of this command</li> <li><code>help_keys</code> (Union(str, list of str), optional) \u2014 help key for bring up help for this command</li> <li><code>help_cmds</code> (Union(str, list of str), optional) \u2014 help command for printing help for other sub-commands of this command</li> <li><code>help_on_void</code> (str or bool, optional) \u2014 whether printing help when no arguments passed</li> <li><code>help_callback</code> (callable, optional) \u2014 callback to manipulate help page</li> <li><code>prefix</code> (str, optional) \u2014 prefix for arguments for this command</li> <li><code>theme</code> (str or Theme, optional) \u2014 The theme of help page for this command</li> <li><code>usage</code> (Union(str, list of str), optional) \u2014 Usage for this command</li> <li><code>group</code> (str, optional) \u2014 Group of this command</li> <li><code>force</code> (bool, optional) \u2014 Force adding when command exists already.</li> <li><code>arbitray</code> \u2014 whether do arbitray Parsing</li> </ul> Returns (Params) <p>The added command</p> method &lt;/&gt; <p>Print the help information and exit</p> Parameters <ul> <li><code>exit_code</code> (int, optional) \u2014 The exit code or False to not exit</li> </ul> method &lt;/&gt; <p>Get a namespace of all parameter name =&gt; value pairs or attach them to the given namespace</p> Parameters <ul> <li><code>namespace</code> (Namespace, optional) \u2014 The namespace for the values to attach to.</li> </ul> Returns (Namespace) <p>the namespace with values of all parameter     name-value pairs</p> method &lt;/&gt; <p>Parse the arguments from the command line</p> Parameters <ul> <li><code>args</code> (list of str, optional) \u2014 The arguments to parse</li> <li><code>ignore_errors</code> (bool, optional) \u2014 Whether to ignore errors. This is helpful to check a specific option or command, but ignore errors, such as required options not provided.</li> </ul> <p>Return:     Namespace: The namespace of parsed arguments</p> method &lt;/&gt; <p>Save the parameters/commands to file.</p> <p>This is helpful if the parameters/commands take time to load. Once can cache this to a file, and load it from it using <code>from_file</code>.</p> Returns (Diot) <p>The complied Diot of parameters and commands</p> method &lt;/&gt; <p>Save the parameters/commands to file.</p> <p>This is helpful if the parameters/commands take time to load. Once can cache this to a file, and load it from it using <code>from_file</code>.</p> Parameters <ul> <li><code>path</code> (str or Path) \u2014 The path to the file</li> <li><code>cfgtype</code> (str, optional) \u2014 The type of the file If not given, will inferred from the suffix of the path Supports one of yaml, toml and json</li> </ul> method &lt;/&gt; <p>Load parameters from file</p> <p>We support 2 types for format to load the parameters.</p> <ul> <li> <p>express way, which has some limitations:</p> <ol> <li>no command definition;</li> <li>no namespace parameters; <pre><code>arg = 1 # default value\n\"arg$desc\" = \"An argument\" # description\n# other attributes\n</code></pre></li> </ol> </li> <li> <p>full specification <pre><code>[params.arg]\ndefault = 1\ndesc = \"An argument\"\n[commands.command]\ndesc = \"A subcommand\"\n\n  [commands.command.params.arg]\n  default = 2\n  desc = \"An argument for command\"\n</code></pre></p> </li> </ul> Parameters <ul> <li><code>filename</code> (str, PathLike, or dict) \u2014 path to the file</li> <li><code>show</code> (bool, optional) \u2014 The default show value for parameters in the file</li> <li><code>force</code> (bool, optional) \u2014 Whether to force adding params/commands</li> <li><code>filetype</code> \u2014 The type of the file. If None, will infer from the filename. Supported types: ini, cfg, conf, config, yml, yaml, json, env, osenv, toml</li> </ul> method &lt;/&gt; <p>Load parameters from python dict</p> Parameters <ul> <li><code>dict_obj</code> (dict) \u2014 A python dictionary to load parameters from</li> <li><code>show</code> (bool, optional) \u2014 The default show value for the parameters in the dictionary</li> <li><code>force</code> (bool, optional) \u2014 Whether to force adding params/commands</li> </ul> method &lt;/&gt; <p>Load parameters from the file specified by naargument from command line</p> <p>This will load the parameters from the file given by the argument, ignoring other arguments from the command line. One can overwrite some of them afterwards, and do the parsing finally.</p> Parameters <ul> <li><code>names</code> (Union(str, list of str, parampath)) \u2014 The names of the parameter or the parameter itself. If it is the parameter, other arguments are ignored</li> <li><code>desc</code> (Union(str, list of str), optional) \u2014 The description of the parameter</li> <li><code>group</code> (str, optional) \u2014 The group of the parameter</li> <li><code>default</code> (str or Path, optional) \u2014 The default value of the file path</li> <li><code>show</code> (bool, optional) \u2014 Whether those parameters should show up in the help page</li> <li><code>force</code> (bool, optional) \u2014 Whether to force adding the parameters/commands</li> <li><code>args</code> (list of str, optional) \u2014 The list of items to parse, otherwise parse sys.argv[1:]</li> </ul> method &lt;/&gt; <p>Copy a Params object</p> Parameters <ul> <li><code>deep</code> (optional) \u2014 Whether to copy the parameters and commands deeply</li> </ul> Returns (Params) <p>The copied params object</p>"},{"location":"api/pyparam.params/#pyparamparams","title":"pyparam.params","text":""},{"location":"api/pyparam.params/#pyparamparamsparams","title":"<code>pyparam.params.</code><code>Params</code><code>(</code><code>names=None</code>, <code>desc=None</code>, <code>prog=None</code>, <code>help_keys=None</code>, <code>help_cmds=None</code>, <code>help_on_void=None</code>, <code>help_callback=None</code>, <code>help_modifier=None</code>, <code>fullopt_keys=None</code>, <code>prefix='auto'</code>, <code>arbitrary=False</code>, <code>theme='default'</code>, <code>usage=None</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamcompletercompletershellcode","title":"<code>shellcode</code><code>(</code><code>shell</code>, <code>python=None</code>, <code>module=False</code><code>)</code> \u2192 str","text":""},{"location":"api/pyparam.params/#pyparamcompletercompletercomplete","title":"<code>complete</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsname","title":"<code>name</code><code>(</code><code>which='short'</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsnamestr","title":"<code>namestr</code><code>(</code><code>sep=', '</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsget_param","title":"<code>get_param</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsget_command","title":"<code>get_command</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsadd_param","title":"<code>add_param</code><code>(</code><code>names</code>, <code>default=None</code>, <code>type=None</code>, <code>desc=None</code>, <code>show=None</code>, <code>required=None</code>, <code>callback=None</code>, <code>group=None</code>, <code>force=False</code>, <code>type_frozen=None</code>, <code>argname_shorten=None</code>, <code>complete_callback=None</code>, <code>**kwargs</code><code>)</code> \u2192 Param","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsadd_command","title":"<code>add_command</code><code>(</code><code>names</code>, <code>desc='No description'</code>, <code>help_keys='__inherit__'</code>, <code>help_cmds='__inherit__'</code>, <code>help_on_void='__inherit__'</code>, <code>help_callback=None</code>, <code>help_modifier=None</code>, <code>prefix='__inherit__'</code>, <code>arbitrary='__inherit__'</code>, <code>theme='__inherit__'</code>, <code>usage=None</code>, <code>group=None</code>, <code>force=False</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsprint_help","title":"<code>print_help</code><code>(</code><code>exit_code=1</code>, <code>full=False</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsvalues","title":"<code>values</code><code>(</code><code>namespace=None</code>, <code>ignore_errors=False</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsparse","title":"<code>parse</code><code>(</code><code>args=None</code>, <code>ignore_errors=False</code><code>)</code> \u2192 Namespace","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsto_dict","title":"<code>to_dict</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsto_file","title":"<code>to_file</code><code>(</code><code>path</code>, <code>cfgtype=None</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsfrom_file","title":"<code>from_file</code><code>(</code><code>filename</code>, <code>show=True</code>, <code>force=False</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsfrom_dict","title":"<code>from_dict</code><code>(</code><code>dict_obj</code>, <code>show=True</code>, <code>force=False</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamsfrom_arg","title":"<code>from_arg</code><code>(</code><code>names</code>, <code>desc='The configuration file.'</code>, <code>group=None</code>, <code>default=None</code>, <code>show=True</code>, <code>force=False</code>, <code>args=None</code><code>)</code>","text":""},{"location":"api/pyparam.params/#pyparamparamsparamscopy","title":"<code>copy</code><code>(</code><code>deep=False</code><code>)</code>","text":""},{"location":"api/pyparam.utils/","title":"pyparam.utils","text":"module &lt;/&gt; <p>Utilities for pyparam</p> Attributes <ul> <li><code>logger</code> \u2014 The logger</li> </ul> Classes <ul> <li><code>Namespace</code> \u2014 Subclass of <code>argparse.Namespace</code>&lt;/&gt;</li> <li><code>Codeblock</code> \u2014 A code block, will be rendered as rich.syntax.Syntax&lt;/&gt;</li> <li><code>RichHandler</code> \u2014 Subclass of rich.logging.RichHandler, showing log levels as a single character&lt;/&gt;</li> </ul> Functions <ul> <li><code>always_list</code><code>(</code><code>str_or_list</code>, <code>strip</code>, <code>split</code><code>)</code> (list of str) \u2014 Convert a string (comma separated) or a list to a list&lt;/&gt;</li> <li><code>cast_to</code><code>(</code><code>value</code>, <code>to_type</code><code>)</code> (any) \u2014 Cast a value to a given type&lt;/&gt;</li> <li><code>parse_potential_argument</code><code>(</code><code>arg</code>, <code>prefix</code>, <code>allow_attached</code><code>)</code> (str, str, str) \u2014 Parse a potential argument with given prefix&lt;/&gt;</li> <li><code>parse_type</code><code>(</code><code>typestr</code><code>)</code> (list of str) \u2014 Parse the type string&lt;/&gt;</li> <li><code>type_from_value</code><code>(</code><code>value</code><code>)</code> (str) \u2014 Detect parameter type from a value&lt;/&gt;</li> </ul> class &lt;/&gt; Bases argparse.Namespace argparse._AttributeHolder <p>Subclass of <code>argparse.Namespace</code></p> <p>We have enabled <code>__getitem__</code>, <code>__setitem__</code>, <code>__len__</code> and <code>__contains__</code>. So that you can do:</p> <pre><code>ns = Namespace()\nns['a'] = 1  # same as ns.a = 1\nns['a'] == 1 # same as ns.a == 1\nlen(ns) == 1\n'a' in ns\n</code></pre> Attributes <ul> <li><code>__command__</code> \u2014 The command name if matched.</li> </ul> class &lt;/&gt; <p>A code block, will be rendered as rich.syntax.Syntax</p> Methods <ul> <li><code>add_code</code><code>(</code><code>code</code><code>)</code> \u2014 Add code to code block&lt;/&gt;</li> <li><code>is_end</code><code>(</code><code>line</code><code>)</code> (bool) \u2014 Tell if the line is the end of the code block&lt;/&gt;</li> <li><code>render</code><code>(</code><code>)</code> (Padding) \u2014 Render the code block to a rich.syntax.Syntax&lt;/&gt;</li> <li><code>scan</code><code>(</code><code>maybe_codeblock</code>, <code>check_default</code><code>)</code> (list of str or Codeblock, Codeblock) \u2014 Scan and try to create codeblock objects from maybe_codeblock&lt;/&gt;</li> <li><code>scan_texts</code><code>(</code><code>texts</code>, <code>check_default</code><code>)</code> (list of str or Codeblock) \u2014 Scan multiple texts for code blocks&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>Scan multiple texts for code blocks</p> Parameters <ul> <li><code>texts</code> (list of str) \u2014 a list of texts</li> <li><code>check_default</code> (bool, optional) \u2014 Check if there is default in maybe_codeblock. Defaults should not be scanned as code blocks</li> <li><code>cls</code> (Codeblock class) \u2014 The class</li> </ul> Returns (list of str or Codeblock) <p>mixed text and code blocks</p> classmethod &lt;/&gt; <p>Scan and try to create codeblock objects from maybe_codeblock</p> Parameters <ul> <li><code>maybe_codeblock</code> (str) \u2014 Maybe a code block start It can be a text block, we have to scan if it has code blocks inside.</li> <li><code>check_default</code> (bool, optional) \u2014 Check if there is default in maybe_codeblock. Defaults should not be scanned as code blocks</li> <li><code>cls</code> (Codeblock class) \u2014 The class</li> </ul> Returns (list of str or Codeblock, Codeblock) <p>mixed text and unclosed code blocks</p> method &lt;/&gt; <p>Add code to code block</p> Parameters <ul> <li><code>code</code> (str) \u2014 code to add It can be multiple lines, each of which will be dedented</li> </ul> method &lt;/&gt; <p>Tell if the line is the end of the code block</p> Parameters <ul> <li><code>line</code> (str) \u2014 line to check</li> </ul> Returns (bool) <p>True if it is the end otherwise False</p> method &lt;/&gt; <p>Render the code block to a rich.syntax.Syntax</p> Returns (Padding) <p>A padding of rich.syntax.Syntax</p> function &lt;/&gt; <p>Convert a string (comma separated) or a list to a list</p> Parameters <ul> <li><code>str_or_list</code> (Union(str, list of str)) \u2014 string or list</li> <li><code>strip</code> (bool, optional) \u2014 whether to strip the elements in result list</li> <li><code>split</code> (str or bool, optional) \u2014 Delimiter for split or False to not split</li> </ul> <p>Return:     list: list of strings</p> function &lt;/&gt; <p>Parse the type string</p> Examples <pre><code>&gt;&gt;&gt; parse_type(None)    # None, None\n&gt;&gt;&gt; parse_type(\"array\") # list, None\n&gt;&gt;&gt; parse_type(\"a:i\")   # list, int\n&gt;&gt;&gt; parse_type(\"j\")     # json, None\n&gt;&gt;&gt; parse_type(\"list\")  # list, None\n</code></pre> Parameters <ul> <li><code>typestr</code> (str) \u2014 string of type to parse</li> </ul> Returns (list of str) <p>Main type and subtype</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When a type cannot be parsed</li> </ul> function &lt;/&gt; <p>Parse a potential argument with given prefix</p> Examples <pre><code>&gt;&gt;&gt; # prefix == 'auto\n&gt;&gt;&gt; parse_potential_argument(\"-a\")     # a, None, None\n&gt;&gt;&gt; parse_potential_argument(\"--arg\")  # arg, None, None\n&gt;&gt;&gt; parse_potential_argument(\"--a\")    # None, None, a\n&gt;&gt;&gt; parse_potential_argument(\"-abc\")   # None, None, -abc\n&gt;&gt;&gt; parse_potential_argument(\"-abc\", allow_attached=True)\n&gt;&gt;&gt; # -a, None, bc\n</code></pre> Parameters <ul> <li><code>arg</code> (str) \u2014 a potential argument. Such as: -a, --def, -b=1, --abc=value, -b1 (for argument -b with value 1) with types: -a:int --def:list -b:str=1 --abs:str=value -b:bool It is usually one element of the sys.argv</li> <li><code>prefix</code> (str) \u2014 The prefix for the argument names</li> <li><code>allow_attached</code> (bool, optional) \u2014 Whether to detect item like '-b1' for argument '-b' with value '1' or the entire one is parsed as argument '-b1'</li> </ul> Returns (str, str, str) <p>The argument name, type and value     When arg cannot be parsed as an argument, argument name and type     will both be None. arg will be returned as argument value.</p> function &lt;/&gt; <p>Detect parameter type from a value</p> Parameters <ul> <li><code>value</code> (any) \u2014 The value</li> </ul> Returns (str) <p>The name of the type</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 When we have list as subtype. For example, when value is <code>[[1]]</code></li> </ul> function &lt;/&gt; <p>Cast a value to a given type</p> Parameters <ul> <li><code>value</code> (any) \u2014 value to cast</li> <li><code>to_type</code> (str or bool) \u2014 type to cast</li> </ul> Returns (any) <p>casted value</p> Raises <ul> <li><code>PyParamTypeError</code> \u2014 if value is not able to be casted</li> </ul> class &lt;/&gt; Bases rich.logging.RichHandler logging.Handler logging.Filterer <p>Subclass of rich.logging.RichHandler, showing log levels as a single character</p> Parameters <ul> <li><code>level</code> (int or str, optional) \u2014 Log level. Defaults to logging.NOTSET.</li> <li><code>show_time</code> (bool, optional) \u2014 Show a column for the time. Defaults to True.</li> <li><code>omit_repeated_times</code> (bool, optional) \u2014 Omit repetition of the same time. Defaults to True.</li> <li><code>show_level</code> (bool, optional) \u2014 Show a column for the level. Defaults to True.</li> <li><code>show_path</code> (bool, optional) \u2014 Show the path to the original log call. Defaults to True.</li> <li><code>enable_link_path</code> (bool, optional) \u2014 Enable terminal link of path column to file. Defaults to True.</li> <li><code>highlighter</code> (Highlighter, optional) \u2014 Highlighter to style log messages, or None to use ReprHighlighter. Defaults to None.</li> <li><code>markup</code> (bool, optional) \u2014 Enable console markup in log messages. Defaults to False.</li> <li><code>rich_tracebacks</code> (bool, optional) \u2014 Enable rich tracebacks with syntax highlighting and formatting. Defaults to False.</li> <li><code>tracebacks_width</code> (int, optional) \u2014 Number of characters used to render tracebacks, or None for full width. Defaults to None.</li> <li><code>tracebacks_extra_lines</code> (int, optional) \u2014 Additional lines of code to render tracebacks, or None for full width. Defaults to None.</li> <li><code>tracebacks_theme</code> (str, optional) \u2014 Override pygments theme used in traceback.</li> <li><code>tracebacks_word_wrap</code> (bool, optional) \u2014 Enable word wrapping of long tracebacks lines. Defaults to True.</li> <li><code>tracebacks_show_locals</code> (bool, optional) \u2014 Enable display of locals in tracebacks. Defaults to False.</li> <li><code>tracebacks_suppress</code> (iterable of str or module, optional) \u2014 Optional sequence of modules or paths to exclude from traceback.</li> <li><code>locals_max_length</code> (int, optional) \u2014 Maximum length of containers before abbreviating, or None for no abbreviation. Defaults to 10.</li> <li><code>locals_max_string</code> (int, optional) \u2014 Maximum length of string before truncating, or None to disable. Defaults to 80.</li> <li><code>log_time_format</code> (Union(str, callable(datetime: text)), optional) \u2014 If <code>log_time</code> is enabled, either string for strftime or callable that formats the time. Defaults to \"[%x %X] \".</li> <li><code>keywords</code> (list of str, optional) \u2014 List of words to highlight instead of <code>RichHandler.KEYWORDS</code>.</li> </ul> Methods <ul> <li><code>acquire</code><code>(</code><code>)</code> \u2014 Acquire the I/O thread lock.&lt;/&gt;</li> <li><code>addFilter</code><code>(</code><code>filter</code><code>)</code> \u2014 Add the specified filter to this handler.&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Tidy up any resources used by the handler.&lt;/&gt;</li> <li><code>createLock</code><code>(</code><code>)</code> \u2014 Acquire a thread lock for serializing access to the underlying I/O.&lt;/&gt;</li> <li><code>emit</code><code>(</code><code>record</code><code>)</code> \u2014 Invoked by logging.&lt;/&gt;</li> <li><code>filter</code><code>(</code><code>record</code><code>)</code> \u2014 Determine if a record is loggable by consulting all the filters.&lt;/&gt;</li> <li><code>flush</code><code>(</code><code>)</code> \u2014 Ensure all logging output has been flushed.&lt;/&gt;</li> <li><code>format</code><code>(</code><code>record</code><code>)</code> \u2014 Format the specified record.&lt;/&gt;</li> <li><code>get_level_text</code><code>(</code><code>record</code><code>)</code> (Text) \u2014 Get the level name from the record.&lt;/&gt;</li> <li><code>handle</code><code>(</code><code>record</code><code>)</code> \u2014 Conditionally emit the specified logging record.&lt;/&gt;</li> <li><code>handleError</code><code>(</code><code>record</code><code>)</code> \u2014 Handle errors which occur during an emit() call.&lt;/&gt;</li> <li><code>release</code><code>(</code><code>)</code> \u2014 Release the I/O thread lock.&lt;/&gt;</li> <li><code>removeFilter</code><code>(</code><code>filter</code><code>)</code> \u2014 Remove the specified filter from this handler.&lt;/&gt;</li> <li><code>render</code><code>(</code><code>record</code>, <code>traceback</code>, <code>message_renderable</code><code>)</code> (ConsoleRenderable) \u2014 Render log for display.&lt;/&gt;</li> <li><code>render_message</code><code>(</code><code>record</code>, <code>message</code><code>)</code> (ConsoleRenderable) \u2014 Render message text in to Text.&lt;/&gt;</li> <li><code>setFormatter</code><code>(</code><code>fmt</code><code>)</code> \u2014 Set the formatter for this handler.&lt;/&gt;</li> <li><code>setLevel</code><code>(</code><code>level</code><code>)</code> \u2014 Set the logging level of this handler.  level must be an int or a str.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Add the specified filter to this handler.</p> method &lt;/&gt; <p>Remove the specified filter from this handler.</p> method &lt;/&gt; <p>Determine if a record is loggable by consulting all the filters.</p> <p>The default is to allow the record to be logged; any filter can veto this and the record is then dropped. Returns a zero value if a record is to be dropped, else non-zero.</p> <p>.. versionchanged:: 3.2</p> <p>Allow filters to be just callables.</p> method &lt;/&gt; <p>Acquire a thread lock for serializing access to the underlying I/O.</p> method &lt;/&gt; <p>Acquire the I/O thread lock.</p> method &lt;/&gt; <p>Release the I/O thread lock.</p> method &lt;/&gt; <p>Set the logging level of this handler.  level must be an int or a str.</p> method &lt;/&gt; <p>Format the specified record.</p> <p>If a formatter is set, use it. Otherwise, use the default formatter for the module.</p> method &lt;/&gt; <p>Conditionally emit the specified logging record.</p> <p>Emission depends on filters which may have been added to the handler. Wrap the actual emission of the record with acquisition/release of the I/O thread lock. Returns whether the filter passed the record for emission.</p> method &lt;/&gt; <p>Set the formatter for this handler.</p> method &lt;/&gt; <p>Ensure all logging output has been flushed.</p> <p>This version does nothing and is intended to be implemented by subclasses.</p> method &lt;/&gt; <p>Tidy up any resources used by the handler.</p> <p>This version removes the handler from an internal map of handlers, _handlers, which is used for handler lookup by name. Subclasses should ensure that this gets called from overridden close() methods.</p> method &lt;/&gt; <p>Handle errors which occur during an emit() call.</p> <p>This method should be called from handlers when an exception is encountered during an emit() call. If raiseExceptions is false, exceptions get silently ignored. This is what is mostly wanted for a logging system - most users will not care about errors in the logging system, they are more interested in application errors. You could, however, replace this with a custom handler if you wish. The record which was being processed is passed in to this method.</p> method &lt;/&gt; <p>Invoked by logging.</p> method &lt;/&gt; <p>Render message text in to Text.</p> Parameters <ul> <li><code>record</code> (LogRecord) \u2014 logging Record.</li> <li><code>message</code> (str) \u2014 String containing log message.</li> </ul> Returns (ConsoleRenderable) <p>Renderable to display log message.</p> method &lt;/&gt; <p>Render log for display.</p> Parameters <ul> <li><code>record</code> (LogRecord) \u2014 logging Record.</li> <li><code>traceback</code> (Optional[Traceback]) \u2014 Traceback instance or None for no Traceback.</li> <li><code>message_renderable</code> (ConsoleRenderable) \u2014 Renderable (typically Text) containing log message contents.</li> </ul> Returns (ConsoleRenderable) <p>Renderable to display log.</p> method &lt;/&gt; <p>Get the level name from the record.</p> Parameters <ul> <li><code>record</code> (LogRecord) \u2014 LogRecord instance.</li> </ul> Returns (Text) <p>A tuple of the style and level name.</p>"},{"location":"api/pyparam.utils/#pyparamutils","title":"pyparam.utils","text":""},{"location":"api/pyparam.utils/#pyparamutilsnamespace","title":"<code>pyparam.utils.</code><code>Namespace</code><code>(</code><code>**kwargs</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilscodeblock","title":"<code>pyparam.utils.</code><code>Codeblock</code><code>(</code><code>opentag</code>, <code>lang</code>, <code>indent</code>, <code>codes=None</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilscodeblockscan_texts","title":"<code>scan_texts</code><code>(</code><code>texts</code>, <code>check_default=False</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilscodeblockscan","title":"<code>scan</code><code>(</code><code>maybe_codeblock</code>, <code>check_default=False</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilscodeblockadd_code","title":"<code>add_code</code><code>(</code><code>code</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilscodeblockis_end","title":"<code>is_end</code><code>(</code><code>line</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilscodeblockrender","title":"<code>render</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilsalways_list","title":"<code>pyparam.utils.</code><code>always_list</code><code>(</code><code>str_or_list</code>, <code>strip=True</code>, <code>split=','</code><code>)</code> \u2192 list of str","text":""},{"location":"api/pyparam.utils/#pyparamutilsparse_type","title":"<code>pyparam.utils.</code><code>parse_type</code><code>(</code><code>typestr</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilsparse_potential_argument","title":"<code>pyparam.utils.</code><code>parse_potential_argument</code><code>(</code><code>arg</code>, <code>prefix</code>, <code>allow_attached=False</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilstype_from_value","title":"<code>pyparam.utils.</code><code>type_from_value</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilscast_to","title":"<code>pyparam.utils.</code><code>cast_to</code><code>(</code><code>value</code>, <code>to_type</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilsrichhandler","title":"<code>pyparam.utils.</code><code>RichHandler</code><code>(</code><code>level=0</code>, <code>console=None</code>, <code>show_time=True</code>, <code>omit_repeated_times=True</code>, <code>show_level=True</code>, <code>show_path=True</code>, <code>enable_link_path=True</code>, <code>highlighter=None</code>, <code>markup=False</code>, <code>rich_tracebacks=False</code>, <code>tracebacks_width=None</code>, <code>tracebacks_extra_lines=3</code>, <code>tracebacks_theme=None</code>, <code>tracebacks_word_wrap=True</code>, <code>tracebacks_show_locals=False</code>, <code>tracebacks_suppress=()</code>, <code>locals_max_length=10</code>, <code>locals_max_string=80</code>, <code>log_time_format='[%x %X]'</code>, <code>keywords=None</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#loggingfiltereraddfilter","title":"<code>addFilter</code><code>(</code><code>filter</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#loggingfiltererremovefilter","title":"<code>removeFilter</code><code>(</code><code>filter</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#loggingfiltererfilter","title":"<code>filter</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandlercreatelock","title":"<code>createLock</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandleracquire","title":"<code>acquire</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandlerrelease","title":"<code>release</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandlersetlevel","title":"<code>setLevel</code><code>(</code><code>level</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandlerformat","title":"<code>format</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandlerhandle","title":"<code>handle</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandlersetformatter","title":"<code>setFormatter</code><code>(</code><code>fmt</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandlerflush","title":"<code>flush</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandlerclose","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#logginghandlerhandleerror","title":"<code>handleError</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#richloggingrichhandleremit","title":"<code>emit</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#richloggingrichhandlerrender_message","title":"<code>render_message</code><code>(</code><code>record</code>, <code>message</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#richloggingrichhandlerrender","title":"<code>render</code><code>(</code><code>record</code>, <code>traceback</code>, <code>message_renderable</code><code>)</code>","text":""},{"location":"api/pyparam.utils/#pyparamutilsrichhandlerget_level_text","title":"<code>get_level_text</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/source/pyparam.completer/","title":"pyparam.completer","text":""},{"location":"api/source/pyparam.completer/","title":"SOURCE CODE pyparam.completer DOCS","text":"<pre><code>\"\"\"Classes for completions\n\nThe idea is inspired from\nhttps://github.com/pallets/click/pull/1622\n\nSome of the code is borrowing there, under following LICENSE:\n\nCopyright 2014 Pallets\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software without\nspecific prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS\nBE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\nGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"\nimport os\nimport re\nimport sys\nfrom hashlib import sha256\nfrom pathlib import Path\nfrom typing import (\n    TYPE_CHECKING,\n    Callable,\n    Generator,\n    Iterator,\n    List,\n    Tuple,\n    Union,\n)\n\nif TYPE_CHECKING:\n    from .param import Param\n\nCOMPLETION_SCRIPT_BASH = \"\"\"\n%(complete_func)s() {\n    local IFS=$'\\\\n'\n    local response\n    response=$( env COMP_WORDS=\"${COMP_WORDS[*]}\" \\\\\n                COMP_CWORD=$COMP_CWORD \\\\\n                %(complete_shell_var)s=bash %(complete_script)s )\n    for completion in $response; do\n        IFS=$'\\\\t' read value type &lt;&lt;&lt; \"$completion\"\n        if [[ $type == 'dir' ]]; then\n            COMREPLY=()\n            compopt -o dirnames\n        elif [[ $type == 'file' ]]; then\n            COMREPLY=()\n            compopt -o filenames\n        elif [[ $type == 'plain' ]]; then\n            COMPREPLY+=($value)\n        fi\n    done\n     return 0\n}\ncomplete -o default -F %(complete_func)s %(script_name)s\n\"\"\"\n\nCOMPLETION_SCRIPT_ZSH = \"\"\"\n#compdef %(script_name)s\n%(complete_func)s() {\n    local -a completions\n    local -a completions_with_descriptions\n    local -a response\n    (( ! $+commands[%(script_name)s] )) &amp;&amp; return 1\n    response=(\"${(@f)$( env COMP_WORDS=\\\"${words[*]}\\\" \\\\\n                        COMP_CWORD=$((CURRENT-1)) \\\\\n                        %(complete_shell_var)s=\\\"zsh\\\" \\\\\n                        %(complete_script)s )}\")\n    for key type descr in ${response}; do\n      if [[ \"$type\" == \"plain\" ]]; then\n        if [[ \"$descr\" == \"\" ]]; then\n          completions+=(\"$key\")\n        else\n          completions_with_descriptions+=(\"$key\":\"$descr\")\n        fi\n      elif [[ \"$type\" == \"dir\" ]]; then\n        _path_files -/\n      elif [[ \"$type\" == \"file\" ]]; then\n        _path_files -f\n      fi\n    done\n     if [ -n \"$completions_with_descriptions\" ]; then\n        _describe -V unsorted completions_with_descriptions -U\n    fi\n     if [ -n \"$completions\" ]; then\n        compadd -U -V unsorted -a completions\n    fi\n    compstate[insert]=\"menucomplete\"\n}\ncompdef %(complete_func)s %(script_name)s\n\"\"\"\n\nCOMPLETION_SCRIPT_FISH = \"\"\"\nfunction %(complete_func)s_complete;\n    set -l response;\n    set -lx COMP_WORDS (commandline -op)\n    set -lx COMP_CWORD ( \\\\\n        math (contains -i -- (commandline -t) $COMP_WORDS; or echo 0)-1 \\\\\n    )\n    set -lx %(complete_shell_var)s fish\n    eval %(complete_script)s | while read completion\n        echo $completion | read -d (echo -e \"\\\\t\") -l -a metadata\n        if [ \"$metadata[2]\" = \"dir\" ];\n            __fish_complete_directories $metadata[1] | sed \"s#^#$metadata[3]#\";\n        else if [ \"$metadata[2]\" = \"file\" ];\n            __fish_complete_path $metadata[1] | sed \"s#^#$metadata[3]#\";\n        else if [ \"$metadata[2]\" = \"plain\" ];\n            echo -n $metadata[1];\n            echo -ne \"\\\\t\";\n            echo $metadata[3];\n        end;\n    end;\nend;\n\n# Don't do complete until &lt;prog&gt; is hit\nfunction %(complete_func)s_condition;\n    set -l COMP_WORDS (commandline -op)\n    set -l comp_script %(complete_script)s\n    set -l len_words (count $COMP_WORDS)\n    set -l len_script (count $comp_script)\n    set -l incomplete (commandline -t)\n    if [ $len_script -eq 1 ];\n        return 0;\n    end\n    # we haven't hit the script or module\n    # go ahead do the complete only when\n    # len_words &gt; len_script\n    # if len_words == len_script, then requires incomplete == \"\"\n    if [ $len_words -lt $len_script ]\n        return 1\n    else if [ $len_words -eq $len_script -a -n \"$incomplete\" ]\n        return 1\n    else if [ $len_script -eq 2 ]\n        [ \"$COMP_WORDS[2]\" = \"$comp_script[2]\" ]; and return 0; or return 1\n    else if [ $len_script -eq 3 ]\n        [ \"$COMP_WORDS[2]\" = \"-m\" -a \"$comp_script[3]\" = \"$COMP_WORDS[3]\" ]; \\\\\n            and return 0; or return 1\n    end\n    return 1\nend;\n\ncomplete --no-files --command %(script_name)s \\\\\n    --condition \"%(complete_func)s_condition\" \\\\\n    --arguments \"(%(complete_func)s_complete)\"\n\"\"\"\n\n\ndef split_arg_string(string: str) -&gt; List[str]:DOCS\n    \"\"\"Given an argument string this attempts to split it into small parts.\n\n    Borrowed from\n    https://github.com/pallets/click/blob/3984f9efce5a0d15f058e1abe1ea808c6abd243a/src/click/parser.py#L106\n\n    Args:\n        string: The string to be split\n\n    Returns:\n        List of split pieces\n    \"\"\"\n    ret: List[str] = []\n    for match in re.finditer(\n        r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'|\"\n        r\"\\\"([^\\\"\\\\]*(?:\\\\.[^\\\"\\\\]*)*)\\\"|\\S+)\\s*\",\n        string,\n        re.S,\n    ):\n        arg = match.group().strip()\n        if arg[:1] == arg[-1:] and arg[:1] in \"\\\"'\":\n            arg = (\n                arg[1:-1]\n                .encode(\"ascii\", \"backslashreplace\")\n                .decode(\"unicode-escape\")\n            )\n        try:\n            arg = type(string)(arg)\n        except UnicodeError:  # pragma: no cover\n            pass\n        ret.append(arg)\n    return ret\n\n\nclass Completer:DOCS\n    \"\"\"Main completion handler\n\n    Attributes:\n        comp_shell: The shell where the completion will be conducted\n            One of ['', 'bash', 'fish', 'zsh']\n            Obtained from environment\n        comp_words: The words have been entered before completion\n        comp_curr: The current word for completion\n        comp_prev: The previous word matched\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor\n\n        Read the environment variables\n        \"\"\"\n        complete_prepared = self._prepare_complete()\n\n        self.comp_shell: str = complete_prepared[0]\n        self.comp_words: List[str] = (\n            complete_prepared[1] if self.comp_shell else None\n        )\n        self.comp_curr: str = complete_prepared[2] if self.comp_shell else None\n        self.comp_prev: str = (\n            None\n            if not self.comp_shell or not self.comp_words\n            else self.comp_words[-1]\n        )\n\n    @propertyDOCS\n    def progvar(self) -&gt; str:\n        \"\"\"Get the program name that can be used as a variable\"\"\"\n        return re.sub(r\"[^\\w_]+\", \"\", self.prog)\n\n    @propertyDOCS\n    def uid(self) -&gt; str:\n        \"\"\"Get the uid based on the raw program name\n\n        This is used as the prefix or suffix of some shell function names\n        \"\"\"\n        return sha256(self.prog.encode()).hexdigest()[:6]\n\n    def _prepare_complete(\n        self,\n    ) -&gt; Tuple[str, List[str], str]:\n        \"\"\"Prepare for completion, get the env variables\"\"\"\n        env_name: str = f\"{self.progvar}_COMPLETE_SHELL_{self.uid}\".upper()\n        shell: str = os.environ.get(env_name, \"\")\n        if not shell:\n            return shell, None, \"\"\n\n        comp_words: List[str] = split_arg_string(os.environ[\"COMP_WORDS\"])\n        comp_cword: int = int(os.environ[\"COMP_CWORD\"] or 0)\n\n        current: str = \"\"\n        if comp_cword &gt;= 0:\n            try:\n                current = comp_words[comp_cword]\n            except IndexError:\n                pass\n\n        has_python: bool = \"python\" in Path(comp_words[0]).stem\n        if has_python and len(comp_words) == 1:\n            sys.exit(0)\n\n        is_module: bool = has_python and comp_words[1] == \"-m\"\n        if is_module and (len(comp_words) &lt; 3 or comp_words[2] != self.prog):\n            sys.exit(0)\n\n        if has_python and not is_module and comp_words[1] != self.prog:\n            sys.exit(0)\n\n        comp_words = comp_words[(3 if is_module else 2 if has_python else 1) :]\n\n        if current and comp_words and comp_words[-1] == current:\n            comp_words.pop(-1)\n\n        if shell == \"bash\" and comp_words:\n            # bash splits '--choice=' to ['--choice'] and '=', and\n            # '--choice=l' to ['--choice', '='] and 'l'\n            # We can't distinguish if user really enters '--choice=' or\n            # '--choice =', but this is the best way to implement this.\n            # Also, bash doesn't replace the current,\n            # so we just need to get the unfinished part\n            if current == \"=\":\n                current = \"\"  # force the unfinished part\n            elif current and comp_words[-1] == \"=\" and len(comp_words) &gt; 1:\n                # pop out the '=' so to force th unfinished part\n                comp_words.pop()\n\n        return shell, comp_words, current\n\n    def _post_complete(\n        self, completions: Iterator[Tuple[str, str, str]]\n    ) -&gt; Generator:\n        \"\"\"Post processing the completions\n\n        Filter only completions with given current word/prefix\n        If non-fish, don't give the description\n        \"\"\"\n        for comp in completions:\n            if self.comp_shell == \"fish\":\n                yield \"\\t\".join(comp)\n            elif self.comp_shell == \"zsh\":\n                yield \"\\n\".join((comp[0] or \" \", comp[1], comp[2]))\n            else:\n                yield \"\\t\".join((comp[0] or \" \", comp[1]))\n\n    def shellcode(DOCS\n        self, shell: str, python: str = None, module: bool = False\n    ) -&gt; str:\n        \"\"\"Generate the shell code to be integrated\n\n        For bash, it should be appended to ~/.profile\n        For zsh, it should be appended to ~/.zprofile\n        For fish, it should be appended to\n            ~/.config/fish/completions/%(prog)s.fish\n            If python is provided, this should go to `python.fish` rather than\n            the `%(prog)s.fish`\n\n        Args:\n            shell: The shell to generate the code for.\n            python: The python name or path to invoke completion.\n            module: Whether do completion for `python -m &lt;prog&gt;`\n\n        Raises:\n            ValueError: if shell is not one of bash, zsh and fish\n        \"\"\"\n\n        if shell == \"zsh\":\n            return self._shellcode_zsh(python=python, module=module)\n        if shell == \"fish\":\n            return self._shellcode_fish(python=python, module=module)\n        if shell == \"bash\":\n            return self._shellcode_bash(python=python, module=module)\n        raise ValueError(f\"Shell not supported: {shell}\")\n\n    def _shellcode_bash(self, python: str, module: bool) -&gt; str:\n        \"\"\"Generate the shell code for bash\"\"\"\n        complete_shell_var: str = (\n            f\"{self.progvar}_COMPLETE_SHELL_{self.uid}\"\n        ).upper()\n        complete_script: str = (\n            \"$1\"\n            if not python\n            else f\"$1 {self.prog}\"\n            if not module\n            else f\"$1 -m {self.prog}\"\n        )\n        complete_func: str = f\"_{self.progvar}_completion_{self.uid}\"\n        return COMPLETION_SCRIPT_BASH % dict(\n            complete_func=complete_func,\n            complete_shell_var=complete_shell_var,\n            complete_script=complete_script,\n            script_name=python or self.prog,\n        )\n\n    def _shellcode_fish(self, python: str, module: bool) -&gt; str:\n        \"\"\"Generate the shell code for fish\"\"\"\n        complete_shell_var: str = (\n            f\"{self.progvar}_COMPLETE_SHELL_{self.uid}\"\n        ).upper()\n        complete_script: str = (\n            \"$COMP_WORDS[1]\"\n            if not python\n            else f\"$COMP_WORDS[1] {self.prog}\"\n            if not module\n            else f\"$COMP_WORDS[1] -m {self.prog}\"\n        )\n        complete_func: str = f\"__fish_{self.progvar}_{self.uid}\"\n        return COMPLETION_SCRIPT_FISH % dict(\n            complete_func=complete_func,\n            complete_shell_var=complete_shell_var,\n            complete_script=complete_script,\n            script_name=python or self.prog,\n        )\n\n    def _shellcode_zsh(self, python: str, module: bool) -&gt; str:\n        \"\"\"Generate the shell code for zsh\"\"\"\n        complete_shell_var: str = (\n            f\"{self.progvar}_COMPLETE_SHELL_{self.uid}\"\n        ).upper()\n        complete_script: str = (\n            \"$words[1]\"\n            if not python\n            else f\"$words[1] {self.prog}\"\n            if not module\n            else f\"$words[1] -m {self.prog}\"\n        )\n        complete_func: str = f\"_{self.progvar}_completion_{self.uid}\"\n        return COMPLETION_SCRIPT_ZSH % dict(\n            complete_func=complete_func,\n            complete_shell_var=complete_shell_var,\n            complete_script=complete_script,\n            script_name=python or self.prog,\n        )\n\n    def _get_param_by_prefixed(self, prefixed: str) -&gt; \"Param\":\n        \"\"\"Get the parameter by the given prefixed name\"\"\"\n        for param in self._all_params(True):\n            if any(\n                param._prefix_name(name) == prefixed for name in param.names\n            ):\n                return param\n        return None\n\n    def _parse_completed(\n        self,\n    ) -&gt; Tuple[List[\"Param\"], bool, str, List[str]]:\n        \"\"\"Parse completed parameters/commands, and give\n        the rest unmatched words. If command matched, also return the command\n\n        Returns:\n            A tuple of:\n                - A list of completed parameters.\n                - A boolean value indicating whether all required parameters\n                    has been completed\n                - Command name if a command matched\n                - Rest of words after the command is matched\n        \"\"\"\n        for i, word in enumerate(self.comp_words):\n            if word in self.commands:\n                return None, None, word, self.comp_words[i + 1 :]\n\n        unmatched_required: bool = False\n        matched: List[\"Param\"] = []\n        matched_append: Callable = matched.append\n        for param in self._all_params(True):\n            if any(\n                param._prefix_name(name) in self.comp_words\n                for name in param.names\n            ):\n                matched_append(param)\n            elif param.required:\n                unmatched_required = True\n\n        return matched, not unmatched_required, None, None\n\n    def complete(self) -&gt; Iterator[str]:DOCS\n        \"\"\"Yields the completions\n\n        Yields:\n            The strings as completion candidates\n        \"\"\"\n        yield from self._post_complete(self._complete())\n\n    def _complete(self) -&gt; Iterator[Tuple[str, str, str]]:\n        \"\"\"Provide the completion candidates\n\n        The rules are:\n        1. When there are uncompleted required parameters, don't give command\n           candidates\n        2. Otherwise, give both command and parameter candidates\n        \"\"\"\n        (\n            completed,\n            all_required_completed,\n            command,\n            rest,\n        ) = self._parse_completed()\n\n        if command:\n            self.commands[command].comp_shell = self.comp_shell\n            self.commands[command].comp_words = rest\n            self.commands[command].comp_curr = self.comp_curr\n            self.commands[command].comp_prev = rest[-1] if rest else None\n            # make sure that help parameters or commands are added\n            self.commands[command].parse()\n            # sys.exit(0)\n\n        completions: Union[\n            str,\n            Iterator[Tuple[str]],\n            Iterator[Tuple[str, str]],\n            Iterator[Tuple[str, str, str]],\n        ] = \"\"\n        param: \"Param\" = None\n        # see if comp_curr is something like '--arg=x'\n        if self.comp_curr and \"=\" in self.comp_curr:\n            prefixed, val = self.comp_curr.split(\"=\", 1)\n            param = self._get_param_by_prefixed(prefixed)\n            completions = (\n                param.complete_value(current=val, prefix=f\"{prefixed}=\")\n                if param\n                else completions\n            )\n        else:\n            param = self._get_param_by_prefixed(self.comp_prev)\n            completions = (\n                param.complete_value(current=self.comp_curr)\n                if param\n                else completions\n            )\n\n        if param:\n            if completions is None:\n                return  # StopIteration\n            if completions is not None and completions:\n                for completion in completions:\n                    yield (\n                        (completion[0], \"plain\", \"\")\n                        if len(completion) == 1\n                        else (\n                            completion[0],\n                            \"plain\",\n                            completion[1],  # type: ignore\n                        )\n                        if len(completion) == 2\n                        else completion\n                    )\n                return  # StopIteration, dont go further\n\n        # no param or completions == ''\n        for param in self._all_params(True):\n            if param.type == \"ns\":\n                continue\n            if param in completed and not param.complete_relapse:\n                continue\n\n            for prefixed_name, desc in param.complete_name(self.comp_curr):\n                yield (prefixed_name, \"plain\", desc)\n\n        if all_required_completed:\n            # see if we have any commands\n            for command_name, command in self.commands.items():\n                if command_name.startswith(self.comp_curr):\n                    yield (\n                        command_name,\n                        \"plain\",\n                        \"Command: \" + command.desc[0].splitlines()[0],\n                    )\n\n\nclass CompleterParam:DOCS\n    \"\"\"Class for a parameter dealing with completion\"\"\"\n\n    complete_relapse: bool = False\n\n    def complete_value(DOCS\n        self, current: str, prefix: str = \"\"\n    ) -&gt; Union[str, Iterator[Tuple[str, ...]]]:\n        \"\"\"Give the completion candidates\n\n        Args:\n            current: Current prefix\n\n        Returns:\n            None when there are no candidates, nor should we have next\n                paramters/commands as candidates (requiring a value).\n                An empty string if we should put next parameters/commands\n                as candidates. Otherwise yields\n                The candidates should be either 1-, 2-, or 3-element tuple.\n                If 1-element, type plain and no description implied.\n                If 2-element, type plain and 2nd element should be description.\n                If 3-element, 2nd element the type, 3rd the description.\n        \"\"\"\n        if callable(self.complete_callback):\n            return self.complete_callback(current, prefix)\n        return None\n\n    def complete_name(self, current: str) -&gt; Iterator[Tuple[str, str]]:DOCS\n        \"\"\"Give the completion name candidates\n\n        Args:\n            current: The current prefix or word under cursor\n\n        Returns:\n            An iterator of a tuple including the prefixed name and description.\n        \"\"\"\n        for name in self.names:\n            prefixed: str = self._prefix_name(name)\n            if prefixed.startswith(current):\n                yield (prefixed, self.desc[0].splitlines()[0])\n</code></pre>"},{"location":"api/source/pyparam.defaults/","title":"pyparam.defaults","text":""},{"location":"api/source/pyparam.defaults/","title":"SOURCE CODE pyparam.defaults DOCS","text":"<pre><code>\"\"\"Defaults for pyparam\n\nHolds some default values for pyparam.\nTo change any of the CONSOLE_WIDTH, HELP_SECTION_INDENT or HELP_OPTION_WIDTH:\n```python\nfrom pyparam import defaults\ndefault.CONSOLE_WIDTH = 100\n```\n\nAttributes:\n    POSITIONAL: The name of positional parameter\n    TYPE_NAMES: The type name mappings to get the type name from aliases\n        Do not modify this variable. It is maintained by\n        `pyparam.param.regiest_param`\n    CONSOLE_WIDTH: The total width for the help page.\n    HELP_SECTION_INDENT: The indentation for the contents in a section\n    HELP_OPTION_WIDTH: The width that the option name and type take up in\n        the help page.\n\"\"\"\nfrom typing import Dict\n\nfrom diot import Diot\n\nPOSITIONAL: str = \"\"\n\n# - Single value types:\n#     auto, int, str, float, bool, count, py, json\n# - Complex value types:\n#     list[&lt;single/complex value type&gt;], ns\nTYPE_NAMES: Dict[str, str] = {}\n\nCONSOLE_WIDTH: int = 80\n# indention for the contents of each section\nHELP_SECTION_INDENT: int = 2\n# The width of the options in help\nHELP_OPTION_WIDTH: int = 34\n\nARGUMENT_REQUIRED = \"Argument is required.\"\n\n# Default attribute values for a Params object\n# This, as well as default attribute values for Param object,\n# are useful to reduce the size of a dumped file\nPARAMS: Diot = Diot(\n    desc=[\"Not described.\"],\n    help_keys=[\"h\", \"help\"],\n    help_cmds=[\"help\"],\n    fullopt_keys=[\"full\"],\n    help_on_void=True,\n    prefix=\"auto\",\n    theme=\"default\",\n    usage=None,\n    arbitrary=False,\n)\n\nPARAM: Diot = Diot(\n    type=None,\n    desc=[\"Not described.\"],\n    default=None,\n    show=True,\n    type_frozen=True,\n    argname_shorten=True,\n    required=False,\n)\n</code></pre>"},{"location":"api/source/pyparam.exceptions/","title":"pyparam.exceptions","text":""},{"location":"api/source/pyparam.exceptions/","title":"SOURCE CODE pyparam.exceptions DOCS","text":"<pre><code>\"\"\"Exceptions used in pyparam\"\"\"\n\n\nclass PyParamException(Exception):DOCS\n    \"\"\"Base exception for pyparam\"\"\"\n\n\nclass PyParamTypeError(PyParamException):DOCS\n    \"\"\"When parameter type is not supported\"\"\"\n\n\nclass PyParamValueError(PyParamException):DOCS\n    \"\"\"When parameter value is improper\"\"\"\n\n\nclass PyParamNameError(PyParamException):DOCS\n    \"\"\"Any errors related to parameter names\"\"\"\n</code></pre>"},{"location":"api/source/pyparam.help/","title":"pyparam.help","text":""},{"location":"api/source/pyparam.help/","title":"SOURCE CODE pyparam.help DOCS","text":"<pre><code>\"\"\"Help assembler for pyparam\n\nAttributes:\n    THEMES: The theme for the help page.\n\"\"\"\nimport re\nimport textwrap\nfrom typing import TYPE_CHECKING, Callable, Dict, List, Tuple, Type, Union\n\nfrom diot import Diot, OrderedDiot\nfrom rich import box  # , print\nfrom rich.console import Console, RenderResult\nfrom rich.console import Group\n\nfrom rich.highlighter import RegexHighlighter\nfrom rich.padding import Padding\nfrom rich.table import Table\nfrom rich.text import Text\nfrom rich.theme import Theme\n\nfrom . import defaults\nfrom .utils import Codeblock\n\nif TYPE_CHECKING:\n    from .params import Params\n\nTHEMES: Dict[str, Theme] = dict(\n    default=Theme(\n        dict(\n            title=\"bold cyan\",\n            prog=\"bold green\",\n            default=\"magenta\",\n            optname=\"bright_green\",\n            opttype=\"blue italic\",\n            opttype_frozen=\"blue\",\n        )\n    ),\n    synthware=Theme(\n        dict(\n            title=\"bold magenta\",\n            prog=\"bold yellow\",\n            default=\"cyan\",\n            optname=\"bright_yellow\",\n            opttype=\"bright_red italic\",\n            opttype_frozen=\"bright_red\",\n        )\n    ),\n)\n\n\nclass ProgHighlighter(RegexHighlighter):DOCS\n    \"\"\"Apply style to anything that looks like a program name.\n\n    Args:\n        prog: The program name\n    \"\"\"\n\n    def __init__(self, prog: str):\n        super().__init__()\n        prog = re.escape(prog)\n        self.highlights = [rf\"(?P&lt;prog&gt;\\b{prog}\\b)\"]\n\n\nclass OptnameHighlighter(RegexHighlighter):DOCS\n    \"\"\"Apply style to anything that looks like a option name.\n\n    Highlight `-b` and `--box` in `-b, --box &lt;INT&gt;`, and all in commands:\n    `i, install`\n    \"\"\"\n\n    highlights: List[str] = [r\"(?P&lt;optname&gt;[^\\[&lt;][^,\\s]+)\"]\n\n\nclass OpttypeHighlighter(RegexHighlighter):DOCS\n    \"\"\"Apply style to anything that looks like a option type.\"\"\"\n\n    highlights: List[str] = [\n        r\"(?P&lt;opttype_frozen&gt;[\\[\\&lt;][A-Z:]+[\\]\\&gt;])$\",\n        r\"(?P&lt;opttype&gt;[\\[\\&lt;][a-z:]+[\\]\\&gt;])$\",\n    ]\n\n\nclass DefaultHighlighter(RegexHighlighter):DOCS\n    \"\"\"Apply style to anything that looks like default value in option desc.\"\"\"\n\n    highlights: List[str] = [r\"(?P&lt;default&gt;D(?:efault|EFAULT):.+$)\"]\n\n\nclass HelpSection(list):DOCS\n    \"\"\"Base class for all help sections.\"\"\"\n\n    def _highlight(\n        self,\n        string: str,\n        highlighters: List[Type[RegexHighlighter]] = None,\n    ) -&gt; Union[Text, str]:\n        \"\"\"Highlight the string using given highlighters\"\"\"\n        if not highlighters:\n            return string\n        if not isinstance(highlighters, (tuple, list)):\n            highlighters = [highlighters]  # type: ignore\n        for highlighter in highlighters:\n            string = highlighter(string)  # type: ignore\n\n        return string\n\n    def __rich_console__(self, console: Console, _) -&gt; RenderResult:DOCS\n        \"\"\"Implement API from rich to print the help page\"\"\"\n        scanned = Codeblock.scan_texts(self)\n        for item in scanned:\n            if isinstance(item, Codeblock):\n                yield Padding(\n                    item.render(), (0, 0, 0, defaults.HELP_SECTION_INDENT)\n                )\n            else:\n                yield Padding(\n                    self._highlight(item, console.meta.highlighters.prog),\n                    (0, 0, 0, defaults.HELP_SECTION_INDENT),\n                )\n\n\nclass HelpSectionPlain(HelpSection):DOCS\n    \"\"\"Plain text section\"\"\"\n\n\nclass HelpSectionUsage(HelpSectionPlain):DOCS\n    \"\"\"Usage section in help\"\"\"\n\n    def _wrap_usage(  # type: ignore\n        self, usage: str, prog: str, *highlighters\n    ) -&gt; Union[Text, str]:\n        \"\"\"Wrap usage line\"\"\"\n        for line in textwrap.wrap(\n            usage,\n            width=defaults.CONSOLE_WIDTH,\n            initial_indent=\" \" * defaults.HELP_SECTION_INDENT,\n            subsequent_indent=\" \"\n            * (defaults.HELP_SECTION_INDENT + len(prog) + 1),\n            break_long_words=False,\n            break_on_hyphens=False,\n        ):\n            yield self._highlight(\n                line.replace(\"*\", \" \"),\n                highlighters,  # type: ignore\n            )\n\n    def __rich_console__(self, console: Console, _) -&gt; RenderResult:DOCS\n        \"\"\"Implement API from rich to print the help page\"\"\"\n        for line in self:\n            usages = self._wrap_usage(\n                line, console.meta.prog, console.meta.highlighters.prog\n            )\n\n            yield Group(*usages)  # type: ignore\n\n\nclass HelpSectionOption(HelpSection):DOCS\n    \"\"\"Options section in help\"\"\"\n\n    def _wrap_opts(  # type: ignore\n        self,\n        opts: List[str],\n        *highlighters,\n    ) -&gt; Union[Text, str]:\n        \"\"\"Wrap the option names and types\"\"\"\n        for opt in opts:\n            for line in textwrap.wrap(\n                opt,\n                width=defaults.HELP_OPTION_WIDTH,\n                initial_indent=\" \" * defaults.HELP_SECTION_INDENT,\n                subsequent_indent=\" \" * (defaults.HELP_SECTION_INDENT + 4),\n                break_long_words=False,\n                break_on_hyphens=False,\n            ):\n                yield self._highlight(\n                    line.replace(\"*\", \" \"),\n                    highlighters,  # type: ignore\n                )\n\n    def _wrap_descs(  # type: ignore\n        self, descs: List[str], default_highlighter: DefaultHighlighter\n    ) -&gt; Union[Text, str]:\n        \"\"\"wrap option descriptions.\n\n        Highlight default value, inline code and code blocks\n\n        Code blocks could be either markdown style:\n        ```python\n        print('Hello world!')\n        ```\n\n        Or a python console style:\n        &gt;&gt;&gt; print('Hello world!')\n        \"\"\"\n        hillight_inline_code: Callable = lambda text: re.sub(\n            r\"(`+)(.+?)\\1\", r\"[code]\\2[/code]\", text\n        )\n\n        descs = Codeblock.scan_texts(descs, check_default=True)\n\n        def wrap_normal(text):\n            for line in textwrap.wrap(\n                text,\n                drop_whitespace=True,\n                width=(\n                    defaults.CONSOLE_WIDTH - defaults.HELP_OPTION_WIDTH - 2\n                ),\n            ):\n                yield self._highlight(hillight_inline_code(line))\n\n        for desc in descs:\n            if isinstance(desc, Codeblock):\n                yield desc.render()\n\n            else:\n                sep: str = (\n                    \"Default:\"\n                    if \"Default:\" in desc\n                    else \"DEFAULT:\"\n                    if \"DEFAULT:\" in desc\n                    else None\n                )\n\n                if sep:\n                    parts: List[str] = desc.split(sep, 1)\n                    # if default is multiline, put it in new line\n                    if \"\\n\" in parts[1]:\n                        yield from wrap_normal(parts[0])\n                        for i, line in enumerate(\n                            parts[1].lstrip().splitlines()\n                        ):\n                            if i == 0:\n                                yield Text(sep + \" \" + line, style=\"default\")\n                            else:\n                                yield Text(\n                                    \" \" * (len(sep) + 1) + line,\n                                    style=\"default\",\n                                )\n                    else:\n                        # use * to connect to avoid default to be wrapped\n                        parts[0] += sep + \"*\" * len(parts[1])\n\n                        # wrap default\n                        for line in textwrap.wrap(\n                            parts[0],\n                            width=(\n                                defaults.CONSOLE_WIDTH\n                                - defaults.HELP_OPTION_WIDTH\n                                - 2\n                            ),\n                            break_long_words=False,\n                            break_on_hyphens=False,\n                        ):\n                            yield self._highlight(\n                                Text.from_markup(  # type: ignore\n                                    hillight_inline_code(line).replace(\n                                        sep + \"*\" * len(parts[1]),\n                                        sep + parts[1].replace(\"[\", r\"\\[\"),\n                                    )\n                                ),\n                                default_highlighter,  # type: ignore\n                            )\n                elif not desc:\n                    yield \"\"\n                else:\n                    yield from wrap_normal(desc)\n\n    def __rich_console__(self, console: Console, _) -&gt; RenderResult:DOCS\n        \"\"\"Implement API from rich to print the help page\"\"\"\n        table = Table(\n            width=defaults.CONSOLE_WIDTH,\n            show_header=False,\n            show_lines=False,\n            show_edge=False,\n            box=box.SIMPLE,\n            expand=True,\n            pad_edge=False,\n            padding=(0, 0, 0, 0),\n        )\n        table.add_column(width=defaults.HELP_OPTION_WIDTH)\n        table.add_column(width=1)\n        table.add_column(\n            width=defaults.CONSOLE_WIDTH - defaults.HELP_OPTION_WIDTH - 1\n        )\n        for param_opts, param_descs in self:\n            table.add_row(\n                Group(  # type: ignore\n                    *self._wrap_opts(\n                        param_opts,\n                        console.meta.highlighters.optname,\n                        console.meta.highlighters.opttype,\n                    )\n                ),\n                Text(\"-\", justify=\"left\"),\n                Group(  # type: ignore\n                    *self._wrap_descs(\n                        param_descs or [], console.meta.highlighters.default\n                    )\n                ),\n            )\n        yield table\n\n\nclass HelpAssembler:DOCS\n    \"\"\"Assemble a help page\n\n    Args:\n        prog: The name of the program\n        theme: The theme for the help page\n\n    Attributes:\n        console: The console to print the help page\n        callback: The callback to modify the help page\n    \"\"\"\n\n    def __init__(\n        self, prog: str, theme: Union[str, Theme], callback: Callable\n    ):\n        \"\"\"Constructor\"\"\"\n        theme = (\n            theme\n            if isinstance(theme, Theme)\n            else THEMES.get(theme, \"default\")  # type: ignore\n        )\n\n        self.console: Console = Console(\n            theme=theme, width=defaults.CONSOLE_WIDTH, tab_size=4\n        )\n        self.callback: Callable = callback\n        self._assembled: List[RenderResult] = None\n\n        self.console.meta = Diot()\n        self.console.meta.prog = prog\n        self.console.meta.highlighters = Diot()\n        self.console.meta.highlighters.prog = ProgHighlighter(prog)\n        self.console.meta.highlighters.optname = OptnameHighlighter()\n        self.console.meta.highlighters.opttype = OpttypeHighlighter()\n        self.console.meta.highlighters.default = DefaultHighlighter()\n\n    def _assemble_description(self, params: \"Params\") -&gt; HelpSectionPlain:\n        \"\"\"Assemble the description section\"\"\"\n        if not params.desc:\n            return None\n\n        return HelpSectionPlain(\n            desc % dict(prog=params.prog) for desc in params.desc\n        )\n\n    def _assemble_usage(self, params: \"Params\", full: bool) -&gt; HelpSectionUsage:\n        \"\"\"Assemble the usage section\"\"\"\n        if not params.usage:\n            # default usage\n            # gather required Arguments\n            usage: List[str] = [\"%(prog)s\"]\n            has_optional = False\n\n            for group in params.param_groups.values():\n                for param in group:\n                    if param.required and (param.show or full):\n                        usage.append(param.usagestr())\n                    elif param.show or full:\n                        has_optional = True\n            if has_optional:\n                usage.append(\"[OPTIONS]\")\n\n            if params.commands:\n                usage.append(\"COMMAND [OPTIONS]\")\n\n            params.usage = [\" \".join(usage)]\n\n        return HelpSectionUsage(\n            usage % dict(prog=params.prog) for usage in params.usage\n        )\n\n    def _assemble_param_groups(  # type: ignore\n        self, params: \"Params\", full: bool\n    ) -&gt; Tuple[str, HelpSectionOption]:\n        \"\"\"Assemble the parameter groups\"\"\"\n\n        for group, param_list in params.param_groups.items():\n            if not full and all(not param.show for param in param_list):\n                continue\n\n            yield group, HelpSectionOption(\n                ([param.optstr()], param.desc_with_default)\n                for param in param_list\n                if param.show or full\n            )\n\n    def _assemble_command_groups(  # type: ignore\n        self, params: \"Params\"\n    ) -&gt; Tuple[str, HelpSectionOption]:\n        \"\"\"Assemble the command groups\"\"\"\n        # command groups\n        for group, cmd_list in params.command_groups.items():\n\n            yield group, HelpSectionOption(\n                ([command.namestr()], command.desc) for command in cmd_list\n            )\n\n    def assemble(self, params: \"Params\", full: bool = False) -&gt; None:DOCS\n        \"\"\"Assemble the help page\n\n        Args:\n            params: The params object\n        \"\"\"\n        self._assembled = []\n\n        assembled: OrderedDiot = OrderedDiot()\n\n        assembled_description: HelpSectionPlain = self._assemble_description(\n            params\n        )\n        if assembled_description:\n            assembled.DESCRIPTION = assembled_description\n\n        assembled_usage: HelpSectionPlain = self._assemble_usage(\n            params, full=full\n        )\n        assembled.USAGE = assembled_usage\n\n        for group, section in self._assemble_param_groups(params, full=full):\n            assembled[group] = section\n\n        for group, section in self._assemble_command_groups(params):\n            assembled[group] = section\n\n        if callable(self.callback):\n            self.callback(assembled)\n\n        for title, section in assembled.items():\n            # end is ignored with rich v11+\n            # see https://github.com/Textualize/rich/issues/2274\n            self._assembled.append(Text(\"\\n\", end=\"\"))  # type: ignore\n            self._assembled.append(\n                Text(  # type: ignore\n                    title + \":\",\n                    style=\"title\",\n                    justify=\"left\",\n                )\n            )\n            self._assembled.append(section)\n\n    def printout(self) -&gt; None:DOCS\n        \"\"\"Print the help page\"\"\"\n        self.console.print(*self._assembled)\n</code></pre>"},{"location":"api/source/pyparam/","title":"pyparam","text":""},{"location":"api/source/pyparam/","title":"SOURCE CODE pyparam DOCS","text":"<pre><code>\"\"\"\nPowerful parameter processing with pyparam\n\"\"\"\nfrom .defaults import POSITIONAL\nfrom .params import Params\nfrom .utils import Namespace\n\n__version__ = \"0.5.4\"\n</code></pre>"},{"location":"api/source/pyparam.param/","title":"pyparam.param","text":""},{"location":"api/source/pyparam.param/","title":"SOURCE CODE pyparam.param DOCS","text":"<pre><code>\"\"\"Definition of a single parameter\n\nAttributes:\n    PARAM_MAPPINGS: The type to Param mappings, used for params to init a\n        parameter. Managed by `register_param`\n\"\"\"\nimport ast\nimport json\nimport re\nfrom itertools import product\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, Iterator, List, Set, Tuple, Type, Union\n\nfrom diot import OrderedDiot\n\nfrom .completer import CompleterParam\nfrom .defaults import ARGUMENT_REQUIRED, POSITIONAL\nfrom .exceptions import (\n    PyParamException,\n    PyParamNameError,\n    PyParamTypeError,\n    PyParamValueError,\n)\nfrom .utils import TYPE_NAMES, Namespace, cast_to, logger, parse_type\n\nPARAM_MAPPINGS: Dict[str, Type[\"Param\"]] = {}\n\n\nclass Param(CompleterParam):DOCS\n    \"\"\"Base class for parameter\n\n    Args:\n        names: The names of the parameter\n        default: The default value\n        desc: The description of the parameter\n        prefix: The prefix of the parameter on the command line\n        show: Whether this parameter should show on help page\n        required: Whether this parameter is required\n        subtype: The subtype of the parameter if\n            this is a complex type\n        type_frozen: Whether the type is frozen\n            (not allowing overwritting from command line)\n        callback: The callback to modify the final value\n        argname_shorten: Whether show shortened name for parameters\n            under namespace parameters\n        complete_callback: The callback for complete the values of the\n            parameter\n        **kwargs: Additional keyword arguments\n\n    Attributes:\n        names: The names of the parameter\n        default: The default value\n        prefix: The prefix of the parameter on the command line\n        show: Whether this parameter should show on help page\n        required: Whether this parameter is required\n        subtype: The subtype of the parameter if this is a complex type\n        type_frozen: Whether the type is frozen\n            (not allowing overwritting from command line)\n        callback: The callback to modify the final value\n        argname_shorten: Whether show shortened name for the parameters\n            under namespace parameters\n        hit: Whether the parameter is just hit\n        ns_param: The namespace parameter where this parameter\n            is under\n        complete_callback: The callback for complete the values of the\n            parameter\n        is_help: Whether this is a help parameter\n        _desc: The raw description of the parameter\n        _stack: The stack to push the values\n        _value_cached: The cached value calculated from the stack\n        _kwargs: other kwargs\n    \"\"\"\n\n    type: str = None\n    type_aliases: List[str] = []\n\n    @classmethodDOCS\n    def on_register(cls):\n        \"\"\"Opens opportunity to do something when a parameter is registered\"\"\"\n\n    def __init__(\n        self,\n        names: Union[str, List[str]],\n        default: Any,\n        desc: List[str],\n        prefix: str = \"auto\",\n        show: bool = True,\n        required: bool = False,\n        subtype: Union[str, bool] = None,\n        type_frozen: bool = True,\n        callback: Callable = None,\n        complete_callback: Callable = None,\n        argname_shorten: bool = True,\n        **kwargs: Dict[str, Any],\n    ):\n        \"\"\"Constructor\"\"\"\n        self.names = names\n        self.default = default\n        self.prefix: str = prefix\n        self.show: bool = show\n        self.required: bool = required\n        self.subtype = subtype\n        self.type_frozen: bool = type_frozen\n        self.callback: Callable = callback\n        self.complete_callback: Callable = complete_callback\n        self.argname_shorten: bool = argname_shorten\n        self.hit: bool = False\n        self.is_help: bool = False\n        self.is_full: bool = False\n        self.ns_param: \"ParamNamespace\" = None\n        self._desc: List[str] = desc or [\"No description.\"]\n        self._stack: List[Any] = []\n        self._value_cached: Any = None\n        self._kwargs: Dict[str, Any] = kwargs\n\n        # check if I am under a namespace\n        # Type: List[List[str]], List[str]\n        self._namespaces, self.terminals = self._extract_namespaces()\n\n    def _extract_namespaces(self) -&gt; Tuple[List[List[str]], List[str]]:\n        \"\"\"Extract the namespace and terminal names\"\"\"\n        nparts: Set[int] = set()\n        namespaces: List[Set[str]] = []\n        terminals: Set[str] = set()\n        for name in self.names:\n            parts: List[str] = name.split(\".\")\n            nparts.add(len(parts))\n            if len(nparts) &gt; 1:\n                raise PyParamNameError(\n                    \"Parameter names must have the same number of namespaces.\"\n                )\n            namespaces = namespaces or [{part} for part in parts[:-1]]\n            for i, part in enumerate(parts[:-1]):\n                namespaces[i].add(part)\n            terminals.add(parts[-1])\n        return [list(ns) for ns in namespaces], list(terminals)\n\n    def _prefix_name(self, name: str) -&gt; str:\n        \"\"\"Add prefix to a name\n\n        Args:\n            name: Name to add prefix to\n\n        Returns:\n            Name with prefix added\n        \"\"\"\n        name_to_check: str = name.split(\".\", 1)[0]\n        if self.prefix == \"auto\":\n            return f\"-{name}\" if len(name_to_check) &lt;= 1 else f\"--{name}\"\n        return f\"{self.prefix}{name}\"\n\n    def namespaces(DOCS\n        self, index: Union[int, str] = \"len\"\n    ) -&gt; Union[List[str], int]:\n        \"\"\"Get the namespaces at the given index or number of namespaces\n\n        Args:\n            index: The index or a length indicator\n\n        Returns:\n            The length of the namespaces or the namespaces at index.\n        \"\"\"\n        if index == \"len\":\n            return len(self._namespaces)\n        try:\n            return self._namespaces[index]  # type: ignore\n        except IndexError:\n            return []\n\n    def full_names(self) -&gt; List[str]:DOCS\n        \"\"\"make the names with full combinations of namespaces and terminals\n\n        Since one can define a parameter like `n.arg` but namespace `n` can\n        have aliases (i.e. `ns`). This makes sure the names of `n.arg` expands\n        to `n.arg` and `ns.arg`\n\n        Returns:\n            The names with full combinations of namespaces and terminals\n        \"\"\"\n        self.names = [\n            \".\".join(prod)\n            for prod in product(*self._namespaces, self.terminals)\n        ]\n        return self.names\n\n    @propertyDOCS\n    def is_positional(self) -&gt; bool:\n        \"\"\"Tell if this parameter is positional\n\n        Returns:\n            True if it is, otherwise False.\n        \"\"\"\n        return POSITIONAL in self.names\n\n    def close(self) -&gt; None:DOCS\n        \"\"\"Close up the parameter while scanning the command line\n\n        We are mostly doing nothing, only if, say, param is bool and\n        it was just hit, we should push a true value to it.\n        \"\"\"\n        if self.hit:\n            logger.warning(\"No value provided for argument %r\", self.namestr())\n\n    def overwrite_type(self, param_type: str) -&gt; \"Param\":DOCS\n        \"\"\"Try to overwrite the type\n\n        Only when param_type is not None and it's different from mine\n        A new param will be returned if different\n\n        Args:\n            param_type: The type to overwrite\n\n        Returns:\n            Self when type not changed otherwise a new parameter with\n                the given type\n        \"\"\"\n        if param_type is None or param_type == self.typestr():\n            return self\n\n        if self.type_frozen:\n            raise PyParamTypeError(\n                f\"Type of argument {self.namestr()!r} \" \"is not overwritable\"\n            )\n        logger.warning(\n            \"Type changed from %r to %r for argument %r\",\n            self.typestr(),\n            param_type,\n            self.namestr(),\n        )\n        return self.to(param_type)\n\n    def consume(self, value: Any) -&gt; bool:DOCS\n        \"\"\"Consume a value\n\n        Args:\n            Value: value to consume\n\n        Returns:\n            True if value was consumed, otherwise False\n        \"\"\"\n        if self.hit or not self._stack:\n            self.push(value)\n            return True\n        return False\n\n    @propertyDOCS\n    def desc(self) -&gt; List[str]:\n        \"\"\"The formatted description using attributes and _kwargs\"\"\"\n        format_data: dict = {\n            key: val\n            for key, val in self.__dict__.items()\n            if (\n                not key.startswith(\"_\") and key != \"desc\" and not callable(val)\n            )\n        }\n        format_data.update(self._kwargs)\n        ret: List[str] = []\n        for descr in self._desc:\n            try:\n                descr = descr % format_data\n            except Exception as kerr:\n                raise PyParamException(\n                    f\"Description of {self.namestr()!r} is formatting \"\n                    \"using kwargs from contructor. \\n\"\n                    f\"- desc: {descr}\\n\"\n                    f\"- key : {{... {str(kerr)[1:-1]} ...}}\"\n                ) from None\n            else:\n                ret.append(descr)\n        return ret\n\n    def name(self, which: str, with_prefix: bool = True) -&gt; str:DOCS\n        \"\"\"Get the shortest/longest name of the parameter\n\n        A name is ensured to be returned. It does not mean it is the real\n        short/long name, but just the shortest/longest name among all the names\n\n        Args:\n            which: Whether get the shortest or longest name\n                Could use `short` or `long` for short.\n            with_prefix: Whether to include the prefix or not\n\n        Returns:\n            The shortest/longest name of the parameter\n        \"\"\"\n        name: str = list(sorted(self.names, key=len))[\n            0 if \"short\" in which else -1\n        ]\n        return name if not with_prefix else self._prefix_name(name)\n\n    def namestr(self, sep: str = \", \", with_prefix: bool = True) -&gt; str:DOCS\n        \"\"\"Get all names connected with a separator.\n\n        Args:\n            sep: The separator to connect the names\n            with_prefix: Whether to include the prefix or not\n        Returns:\n            the connected names\n        \"\"\"\n        names: list = [\n            \"POSITIONAL\"\n            if name == POSITIONAL\n            else self._prefix_name(name)\n            if with_prefix\n            else name\n            for name in sorted(self.names, key=len)\n        ]\n        return sep.join(names)\n\n    def typestr(self) -&gt; str:DOCS\n        \"\"\"Get the string representation of the type\n\n        Returns:\n            the string representation of the type\n        \"\"\"\n        return self.type if not self.subtype else f\"{self.type}:{self.subtype}\"\n\n    def usagestr(self) -&gt; str:DOCS\n        \"\"\"Get the string representation of the parameter in the default usage\n        constructor\n\n        Returns:\n            the string representation of the parameter in the default usage\n        \"\"\"\n        # * makes sure it's not wrapped\n        ret: str = self.name(\"long\") + \"*\"\n        ret += self.typestr().upper() if self.type_frozen else self.typestr()\n        return ret\n\n    def optstr(self) -&gt; str:DOCS\n        \"\"\"Get the string representation of the parameter names and types\n        in the optname section in help page\n\n        Returns:\n            the string representation of the parameter names and types\n                in the optname section in help page\n        \"\"\"\n        typestr: str = (\n            self.typestr().upper() if self.type_frozen else self.typestr()\n        )\n        if not self.ns_param or not self.argname_shorten:\n            # * makes sure it's not wrapped\n            return (\n                self.namestr()\n                if self.is_help\n                else f\"{self.namestr()}*&lt;{typestr}&gt;\"\n            )\n\n        ret: List[str] = []\n        for term in sorted(self.terminals, key=len):\n            ret.append(f\"~&lt;ns&gt;.{term}\")\n        return \", \".join(ret) + f\"*&lt;{typestr}&gt;\"\n\n    def to(self, to_type: str) -&gt; \"Param\":DOCS\n        \"\"\"Generate a different type of parameter using current settings\n\n        Args:\n            to_type: the type of parameter to generate\n\n        Returns:\n            the generated parameter with different type\n        \"\"\"\n        main_type, sub_type = parse_type(to_type)\n        klass: Callable = PARAM_MAPPINGS[main_type]\n        param: \"Param\" = klass(\n            names=self.names,\n            default=None,\n            desc=self.desc,\n            prefix=self.prefix,\n            show=self.show,\n            required=self.required,\n            subtype=sub_type,\n            callback=self.callback,\n            complete_callback=self.complete_callback,\n            argname_shorten=self.argname_shorten,\n            **self._kwargs,\n        )\n        param.ns_param = self.ns_param\n        return param\n\n    def copy(self) -&gt; \"Param\":DOCS\n        \"\"\"Copy a parameter so that it can be reused.\n\n        Returns:\n            The copy of the parameter\n        \"\"\"\n        return self.__class__(\n            names=self.names,\n            default=self.default,\n            desc=self.desc,\n            prefix=self.prefix,\n            show=self.show,\n            required=self.required,\n            subtype=self.subtype,\n            callback=self.callback,\n            type_frozen=self.type_frozen,\n            complete_callback=self.complete_callback,\n            argname_shorten=self.argname_shorten,\n            **self._kwargs,\n        )\n\n    @propertyDOCS\n    def default_group(self) -&gt; str:\n        \"\"\"Get the default group of the parameter\n\n        Returns:\n            the default group name\n        \"\"\"\n        ret: str = \"REQUIRED OPTIONS\" if self.required else \"OPTIONAL OPTIONS\"\n        return (\n            ret\n            if not self.ns_param\n            else f\"{ret} UNDER {self.ns_param.name('long')}\"\n        )\n\n    @propertyDOCS\n    def desc_with_default(self) -&gt; List[str]:\n        \"\"\"If default is not specified in desc, just to add with the default\n        value\n\n        Returns:\n            list of descriptions with default value added\n        \"\"\"\n        if self.is_help:\n            return self.desc\n\n        if self.required or (\n            self.desc\n            and any(\n                \"Default:\" in desc or \"DEFAULT:\" in desc for desc in self.desc\n            )\n        ):\n            return None if self.desc is None else self.desc[:]\n\n        desc: List[str] = self.desc[:] if self.desc else [\"\"]\n        if desc[0] and not desc[0][-1:].isspace():\n            desc[0] += \" \"\n\n        default_str: str = str(self.default) or \"''\"\n        desc[0] += f\"Default: {default_str}\"\n        return desc\n\n    def push(self, item: Any) -&gt; None:DOCS\n        \"\"\"Push a value into the stack for calculating\n\n        Returns:\n            The item to be pushed\n        \"\"\"\n        if self.hit is True and self._stack:\n            logger.warning(\n                \"Previous value of argument %r is overwritten with %r.\",\n                self.namestr(),\n                item,\n            )\n            self._stack = []\n\n        if self.hit or not self._stack:\n            self._stack.append([])\n        self._stack[-1].append(item)\n        self.hit = False\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"&lt;{self.__class__.__name__}({self.namestr()} :: \"\n            f\"{self.typestr()}) @ {id(self)}&gt;\"\n        )\n\n    def _value(self) -&gt; Any:\n        \"\"\"Get the organized value of this parameter\n\n        Returns:\n            The parsed value of thie parameter\n        \"\"\"\n        if not self._stack:\n            if self.required:\n                raise PyParamValueError(\"Argument is required.\")\n            return self.default\n        ret = self._stack[-1][0]\n        self._stack = []\n        return ret\n\n    @propertyDOCS\n    def value(self) -&gt; Any:\n        \"\"\"Return the cached value if possible, otherwise calcuate one\n\n        Returns:\n            The cached value of this parameter or the newly calculated\n                from stack\n        \"\"\"\n        if self._value_cached is not None:\n            return self._value_cached\n        self._value_cached = self._value()\n        return self._value_cached\n\n    def apply_callback(self, all_values: Namespace) -&gt; Any:DOCS\n        \"\"\"Apply the callback function to the value\n\n        Args:\n            all_values: The namespace of values of all parameters\n\n        Returns:\n            The value after the callback applied\n\n        Raises:\n            PyParamTypeError: When exceptions raised or returned from callback\n        \"\"\"\n        if not callable(self.callback):\n            return self.value\n\n        try:\n            val = self.callback(self.value, all_values)\n        except TypeError as terr:  # pragma: no cover\n            # len() takes exactly one argument (2 given)\n            # &lt;lambda&gt;() takes 1 positional argument but 2 were given\n            if not re.search(r\"takes .+ argument .+ given\", str(terr)):\n                raise\n            val = self.callback(self.value)\n\n        if isinstance(val, Exception):\n            raise PyParamTypeError(str(val))\n        return val\n\n\nclass ParamAuto(Param):DOCS\n    \"\"\"An auto parameter whose value is automatically casted\"\"\"\n\n    type: str = \"auto\"\n\n    def _value(self) -&gt; Any:\n        \"\"\"Cast value automatically\"\"\"\n        return cast_to(super()._value(), \"auto\")\n\n\nclass ParamInt(Param):DOCS\n    \"\"\"An int parameter whose value is automatically casted into an int\"\"\"\n\n    type: str = \"int\"\n    type_aliases: List[str] = [\"i\"]\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # self.default = self.default or 0\n\n    def _value(self) -&gt; int:\n        val = super()._value()\n        try:\n            return None if val is None else int(val)\n        except ValueError as verr:\n            raise PyParamValueError(str(verr)) from None\n\n\nclass ParamFloat(Param):DOCS\n    \"\"\"A float parameter whose value is automatically casted into a float\"\"\"\n\n    type: str = \"float\"\n    type_aliases: List[str] = [\"f\"]\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # self.default = self.default or 0.0\n\n    def _value(self) -&gt; float:\n        val = super()._value()\n        try:\n            return None if val is None else float(val)\n        except ValueError as verr:  # pragma: no cover\n            raise PyParamValueError(str(verr)) from None\n\n\nclass ParamStr(Param):DOCS\n    \"\"\"A str parameter whose value is automatically casted into a str\"\"\"\n\n    type: str = \"str\"\n    type_aliases: List[str] = [\"s\"]\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # self.default = self.default or ''\n\n\nclass ParamBool(Param):DOCS\n    \"\"\"A bool parameter whose value is automatically casted into a bool\"\"\"\n\n    type: str = \"bool\"\n    type_aliases: List[str] = [\"b\", \"flag\"]\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # self.default = self.default or False\n        if self.default is not None:\n            try:\n                self.default = cast_to(str(self.default), \"bool\")\n            except (PyParamValueError, PyParamTypeError):\n                raise PyParamValueError(\n                    \"Default value of a count argument must be a bool value or \"\n                    \"a value that can be casted to a bool value.\"\n                ) from None\n\n    def usagestr(self) -&gt; str:DOCS\n        \"\"\"Get the string representation of the parameter in the default usage\n        constructor\n\n        Returns:\n            the string representation of the parameter in the default usage\n        \"\"\"\n        return self.name(\"long\")\n\n    def optstr(self) -&gt; str:DOCS\n        \"\"\"Get the string representation of the parameter names and types\n        in the optname section in help page\n\n        Returns:\n            the string representation of the parameter names and types\n                in the optname section in help page\n        \"\"\"\n        if self.is_help:\n            return self.namestr()\n        typestr: str = (\n            self.typestr().upper() if self.type_frozen else self.typestr()\n        )\n\n        if not self.ns_param or not self.argname_shorten:\n            # * makes sure it's not wrapped'\n            return f\"{self.namestr()}*[{typestr}]\"\n\n        ret: List[str] = []\n        for term in sorted(self.terminals, key=len):\n            ret.append(f\"~&lt;ns&gt;.{term}\")\n        return \", \".join(ret) + f\"*[{typestr}]\"\n\n    def close(self) -&gt; None:DOCS\n        if self.hit is True:\n            self.push(\"true\")\n\n    def consume(self, value: str) -&gt; bool:DOCS\n        \"\"\"Should I consume given value?\"\"\"\n        if not self.hit:\n            return False\n\n        try:\n            cast_to(value, \"bool\")\n        except (PyParamValueError, PyParamTypeError):\n            return False  # cannot cast, don't consume\n        else:\n            self.push(value)\n            return True\n\n    def _value(self) -&gt; bool:\n        if not self._stack:\n            return self.default\n\n        val = self._stack[-1][0]\n        ret = None if val is None else cast_to(val, \"bool\")\n        self._stack = []\n        return ret\n\n    def complete_value(DOCS\n        self, current: str, prefix: str = \"\"\n    ) -&gt; Union[\n        str,\n        Iterator[Tuple[str]],\n        Iterator[Tuple[str, str]],\n        Iterator[Tuple[str, str, str]],\n    ]:\n        \"\"\"Get the completion candidates for the current parameter\"\"\"\n        if self.is_help:\n            return \"\"\n        if callable(self.complete_callback):\n            return super().complete_value(current, prefix)\n        if current:\n            trues: List[str] = (\"True\", \"true\", \"TRUE\", \"1\")\n            falses: List[str] = (\"False\", \"false\", \"FALSE\", \"0\")\n            ret: List[Tuple[str, str, str]] = []\n            for cand in trues:\n                if cand.startswith(current):\n                    ret.append((f\"{prefix}{cand}\", \"plain\", \"Value True\"))\n\n            for cand in falses:\n                if cand.startswith(current):\n                    ret.append((f\"{prefix}{cand}\", \"plain\", \"Value False\"))\n            return ret\n        return \"\"\n\n\nclass ParamCount(Param):DOCS\n    \"\"\"A bool parameter whose value is automatically casted into a bool\"\"\"\n\n    type: str = \"count\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        self.default = self.default or 0\n        if self.default is not None and self.default != 0:\n            raise PyParamValueError(\n                \"Default value of a count argument must be 0\"\n            )\n\n        if len(self.name(\"short\", with_prefix=False)) != 1:\n            raise PyParamValueError(\"Count argument must have a short name.\")\n\n        self._kwargs.setdefault(\"max\", 0)  # 0: no max\n        if not isinstance(self._kwargs[\"max\"], int) or self._kwargs[\"max\"] &lt; 0:\n            raise PyParamValueError(\n                \"Argument 'max' for count argument must be a positive integer\"\n            )\n\n    def close(self) -&gt; None:DOCS\n        if self.hit is True:\n            self.push(\"1\")\n\n    def consume(self, value: str) -&gt; bool:DOCS\n        \"\"\"Should I consume given parameter?\"\"\"\n        if self.hit and value.isdigit():\n            self.push(value)\n            return True\n        return False\n\n    def _value(self) -&gt; int:\n        val = super()._value()\n\n        retval = None\n        if str(val).isdigit():\n            retval = int(val)\n        else:\n            for name in self.names:\n                if len(name) != 1:\n                    continue\n                if name * len(val) == val:\n                    # -vvv =&gt; name: v, value: vv\n                    # len(vv) = 2, but value should be 3\n                    retval = len(val) + 1\n                    break\n        if retval is None:\n            raise PyParamValueError(\n                \"Expect repeated short names or \"\n                \"an integer as count argument value.\"\n            )\n        if self._kwargs[\"max\"] and retval &gt; self._kwargs[\"max\"]:\n            raise PyParamValueError(\n                f\"{retval} is greater than \"\n                f\"the max of {self._kwargs['max']}.\"\n            )\n        return retval\n\n    def complete_name(self, current: str) -&gt; Iterator[Tuple[str, str]]:DOCS\n        \"\"\"Complete names for a count parameter\n\n        Since we have -v, -vv, -vvv allowed for a count parameter, we need\n        to put them in the completions, too.\n        \"\"\"\n        # check if current is trying to do so\n        for name in self.names:\n            if len(name) != 1:\n                continue\n            # current is not like -vvv\n            if self._prefix_name(name) + len(current[2:]) * name != current:\n                continue\n            # check the max\n            value: int = len(current) - 1\n            if self._kwargs[\"max\"] and value &gt;= self._kwargs[\"max\"]:\n                # already max'ed, no further completion\n                continue\n\n            ncompletes: int = (\n                min(self._kwargs[\"max\"] - value, 2)\n                if self._kwargs[\"max\"]\n                else 2\n            )\n            for i in range(ncompletes):\n                yield current + name * (i + 1), self.desc[0].splitlines()[0]\n            break\n\n        else:\n            yield from super().complete_name(current)\n\n\nclass ParamPath(Param):DOCS\n    \"\"\"A path parameter whose value is automatically casted into a pathlib.Path\n    \"\"\"\n\n    type: str = \"path\"\n    type_aliases: List[str] = [\"p\", \"file\"]\n\n    def _value(self) -&gt; Path:\n        val: Path = super()._value()\n        return None if val is None else Path(val)\n\n    def complete_value(DOCS\n        self, current: str, prefix: str = \"\"\n    ) -&gt; Union[str, Iterator[Tuple[str, ...]]]:\n        \"\"\"Generate file paths with given current prefix\n        as completion candidates\n\n        Args:\n            current: The current word or prefix under cursor\n        \"\"\"\n        if callable(self.complete_callback):\n            return super().complete_value(current, prefix)\n        return [(current, \"file\", prefix)]\n\n\nclass ParamDir(ParamPath):DOCS\n    \"\"\"Subclass of ParamPath.\n\n    It does not make any difference with pyparam. However, it works differently\n    for completions. The completion items for this param will only give\n    directories instead of all paths\n    \"\"\"\n\n    type: str = \"dir\"\n    type_aliases: List[str] = []\n\n    def complete_value(DOCS\n        self, current: str, prefix: str = \"\"\n    ) -&gt; Union[str, Iterator[Tuple[str, ...]]]:\n        \"\"\"Generate dir paths with given current prefix as completion candidates\n\n        Args:\n            current: The current word or prefix under cursor\n        \"\"\"\n        if callable(self.complete_callback):\n            return super().complete_value(current, prefix)\n        return [(current, \"dir\", prefix)]\n\n\nclass ParamPy(Param):DOCS\n    \"\"\"A parameter whose value will be ast.literal_eval'ed\"\"\"\n\n    type: str = \"py\"\n\n    def _value(self) -&gt; Any:\n        return ast.literal_eval(str(super()._value()))\n\n\nclass ParamJson(Param):DOCS\n    \"\"\"A parameter whose value will be parsed as json\"\"\"\n\n    type: str = \"json\"\n    type_aliases: List[str] = [\"j\"]\n\n    def _value(self) -&gt; Any:\n        val: Any = super()._value()\n\n        if val is None:  # pragma: no cover\n            return None\n\n        if isinstance(val, str):\n            return json.loads(val)\n\n        return json.loads(json.dumps(val))\n\n\nclass ParamList(Param):DOCS\n    \"\"\"A parameter whose value is a list\"\"\"\n\n    type: str = \"list\"\n    type_aliases: List[str] = [\"l\", \"a\", \"array\"]\n    complete_relapse: bool = True\n\n    @classmethodDOCS\n    def on_register(cls):\n        \"\"\"Also register reset type\"\"\"\n        name = \"reset\"\n        aliases = [\"r\"]\n        all_names = [name] + aliases\n\n        for nam in all_names:\n            TYPE_NAMES[nam] = name\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.default = self.default or []\n        self._stack.append(self.default)\n\n    def overwrite_type(self, param_type: str) -&gt; \"Param\":DOCS\n        \"\"\"Deal with when param_type is reset\"\"\"\n        if param_type == \"reset\":\n            self._stack = []\n            return self\n        return super().overwrite_type(param_type)\n\n    def consume(self, value: str) -&gt; bool:DOCS\n        \"\"\"Should I consume given parameter?\"\"\"\n        self.push(value)\n        return True\n\n    def push(self, item: str):DOCS\n        \"\"\"Push a value into the stack for calculating\"\"\"\n        if self.hit or not self._stack:\n            self._stack.append([])\n        self._stack[-1].append(item)\n        self.hit = False\n\n    def _value(self) -&gt; List[Any]:\n        \"\"\"Get the value a list parameter\"\"\"\n        ret = [\n            cast_to(val, self.subtype)\n            for sublist in self._stack\n            for val in sublist\n        ]\n\n        if self.required and not ret:\n            raise PyParamValueError(ARGUMENT_REQUIRED)\n        self._stack = []\n        return ret\n\n\nclass ParamChoice(Param):DOCS\n    \"\"\"A bool parameter whose value is automatically casted into a bool\"\"\"\n\n    type: str = \"choice\"\n    type_aliases: List[str] = [\"c\"]\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if \"choices\" not in self._kwargs:\n            raise PyParamValueError(\n                \"Argument 'choices' is required \" \"for ParamChoice.\"\n            )\n\n        if not isinstance(self._kwargs[\"choices\"], (list, tuple)):\n            raise PyParamValueError(\n                \"Argument 'choices' must be \" \"a list or a tuple.\"\n            )\n\n        # if not self.required and self.default is None:\n        #     self.default = self._kwargs['choices'][0]\n\n    def _value(self) -&gt; Any:\n        val = super()._value()\n\n        if val is not None and val not in self._kwargs[\"choices\"]:\n            raise PyParamValueError(\n                f\"{val} is not one of {self._kwargs['choices']}\"\n            )\n        self._stack = []\n        return val\n\n    def complete_value(DOCS\n        self, current: str, prefix: str = \"\"\n    ) -&gt; Union[str, Iterator[Tuple[str, ...]]]:\n        \"\"\"Generate choices with given current prefix as completion candidates\n\n        Args:\n            current: The current word or prefix under cursor\n        \"\"\"\n        if callable(self.complete_callback):\n            return super().complete_value(current, prefix)\n\n        ret: Iterator[Tuple[str]] = []\n        for choice in self._kwargs[\"choices\"]:\n            if choice.startswith(current):\n                ret.append((f\"{prefix}{choice}\",))\n        return ret\n\n\nclass ParamNamespace(Param):DOCS\n    \"\"\"A pseudo parameter serving as a namespace for parameters under it\n\n    So that it is possible to do:\n    ```shell\n    prog --namespace.arg1 1 --namespace.arg2 2\n    ```\n    \"\"\"\n\n    type: str = \"ns\"\n    type_aliases: List[str] = [\"namespace\"]\n\n    def __init__(self, *args, **kwargs):\n        kwargs[\"desc\"] = kwargs.get(\"desc\") or [\n            \"Works as a namespace for other arguments.\",\n            \"Never pass a value directly to it.\",\n        ]\n        kwargs[\"default\"] = None\n        super().__init__(*args, **kwargs)\n        self._stack = OrderedDiot()  # for my decendents\n\n    @propertyDOCS\n    def default_group(self) -&gt; str:\n        \"\"\"Get the default group of the parameter\"\"\"\n        ret: str = (\n            \"REQUIRED\"\n            if any(param.required for param in self._stack.values())\n            else \"OPTIONAL\"\n        )\n        return (\n            f\"{ret} OPTIONS\"\n            if not self.ns_param\n            else f'{ret} OPTIONS UNDER {self.ns_param.name(\"long\")}'\n        )\n\n    @propertyDOCS\n    def desc_with_default(self) -&gt; List[str]:\n        \"\"\"Namespace parameters do not have a default value\"\"\"\n        return self.desc[:]\n\n    def decendents(self, show_only=False) -&gt; List[\"Param\"]:DOCS\n        \"\"\"Get all decendents of this namespace parameter\n\n        Args:\n            show_only: Load params with show=True only?\n\n        Returns:\n            The decendents of this namespace parameter\n        \"\"\"\n        ret: List[\"Param\"] = []\n        ret_append: Callable = ret.append\n        for param in self._stack.values():\n            # don't skip entire ns parameter\n            if isinstance(param, ParamNamespace):\n                if (not show_only or param.show) and param not in ret:\n                    ret.append(param)\n                ret.extend(param.decendents(show_only))\n                continue\n            if show_only and not param.show:\n                continue\n            if param not in ret:\n                ret_append(param)\n        return ret\n\n    def consume(self, value: str) -&gt; bool:DOCS\n        \"\"\"Should I consume given parameter?\"\"\"\n        return False\n\n    def get_param(self, name: str, depth: int = 0) -&gt; \"Param\":DOCS\n        \"\"\"Get the paraemeter by given name\n\n        This parameter is like '-a', and the name can be 'a.b.c.d'\n\n        Args:\n            name: The name of the parameter to get\n            depth: The depth\n\n        Returns:\n            The parameter we get with the given name\n        \"\"\"\n        parts: List[str] = name.split(\".\")\n        if depth &lt; len(parts) - 1:\n            part = parts[depth + 1]\n            if part not in self._stack:\n                return None\n            if not isinstance(\n                self._stack[part],  # type: ignore\n                ParamNamespace,\n            ):\n                return self._stack[part]  # type: ignore\n            return self._stack[part].get_param(name, depth + 1)  # type: ignore\n        if name in self.names:\n            return self\n        return None\n\n    def push(self, item: \"Param\", depth: int = 0) -&gt; None:DOCS\n        \"\"\"Push the parameter under this namespace.\n\n        We are not pushing any values to this namespace, but pushing\n        parameters that are under it.\n        \"\"\"\n        # check if item's namespaces at depth contain only names of this\n        # ns parameter\n        if set(item.namespaces(depth)) - set(self.terminals):  # type: ignore\n            raise PyParamValueError(\n                \"Parameter names should only contain namespace names \"\n                \"that belong to the same namespace parameter.\"\n            )\n\n        # set the names with all possible combination\n        item._namespaces[depth] = self.terminals  # [:]\n        item.full_names()\n\n        # check if we have nested namespaces\n        if 0 &lt;= depth &lt; item.namespaces(\"len\") - 1:  # type: ignore\n            # see if sub-ns exists\n            subns_name = item.namespaces(depth + 1)[0]  # type: ignore\n            if subns_name in self._stack:\n                subns = self._stack[subns_name]  # type: ignore\n            else:\n                subns = ParamNamespace(\n                    [\n                        \".\".join(prod)\n                        for prod in product(\n                            *(\n                                item.namespaces(i)  # type: ignore\n                                for i in range(depth + 2)\n                            )\n                        )\n                    ]\n                )\n                subns.ns_param = self\n\n                for name in subns.terminals:\n                    self._stack[name] = subns\n            subns.push(item, depth + 1)\n        else:\n            item.ns_param = self\n            for term in item.terminals:\n                self._stack[term] = item  # type: ignore\n\n    def _value(self) -&gt; Namespace:\n        val = Namespace()\n        for param_name, param in self._stack.items():\n            if param_name not in val:\n                for name in param.terminals:\n                    val[name] = param.value\n        return val\n\n    def copy(self) -&gt; \"Param\":DOCS\n        \"\"\"Copy a parameter so that it can be reused.\n\n        Returns:\n            The copy of the parameter\n        \"\"\"\n        copied = super().copy()\n        copied._stack = OrderedDiot(\n            [(key, param.copy()) for key, param in self._stack.items()]\n        )\n        return copied\n\n    def apply_callback(self, all_values: Namespace) -&gt; Any:DOCS\n        ns_callback_applied = Namespace()\n        for param_name, param in self._stack.items():\n            if param_name not in ns_callback_applied:\n                for name in param.terminals:\n                    ns_callback_applied[name] = param.apply_callback(\n                        all_values\n                    )\n\n        if not callable(self.callback):\n            return ns_callback_applied\n\n        try:\n            val = self.callback(ns_callback_applied, all_values)\n        except TypeError as terr:  # pragma: no cover\n            # len() takes exactly one argument (2 given)\n            # &lt;lambda&gt;() takes 1 positional argument but 2 were given\n            if not re.search(r\"takes .+ argument .+ given\", str(terr)):\n                raise\n            val = self.callback(ns_callback_applied)\n\n        if isinstance(val, Exception):\n            raise PyParamTypeError(str(val))\n        return val\n\n\ndef register_param(param: Type[Param]) -&gt; None:DOCS\n    \"\"\"Register a parameter class\n\n    Args:\n        param: The param to register\n            A param class should include a type\n            You can also define type alias for a param type\n    \"\"\"\n    for alias in param.type_aliases + [param.type]:\n        if alias in TYPE_NAMES:\n            raise PyParamNameError(\n                \"Type name has already been \" f\"registered: {alias}\"\n            )\n        TYPE_NAMES[alias] = param.type\n\n    PARAM_MAPPINGS[param.type] = param\n    param.on_register()\n\n\nfor param_class in (\n    ParamAuto,\n    ParamInt,\n    ParamStr,\n    ParamFloat,\n    ParamBool,\n    ParamCount,\n    ParamPath,\n    ParamDir,\n    ParamPy,\n    ParamJson,\n    ParamList,\n    ParamChoice,\n    ParamNamespace,\n):\n    register_param(param_class)\n</code></pre>"},{"location":"api/source/pyparam.params/","title":"pyparam.params","text":""},{"location":"api/source/pyparam.params/","title":"SOURCE CODE pyparam.params DOCS","text":"<pre><code>\"\"\"Definition of Params\"\"\"\nimport sys\nfrom os import PathLike\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Tuple, Type, Union\n\nimport rich\nfrom diot import Diot, OrderedDiot\nfrom simpleconf import Config\n\nfrom .completer import Completer\nfrom .defaults import PARAM as PARAM_DEFAULT\nfrom .defaults import PARAMS as PARAMS_DEFAULT\nfrom .defaults import POSITIONAL\nfrom .exceptions import PyParamNameError, PyParamTypeError, PyParamValueError\nfrom .help import HelpAssembler, ProgHighlighter\nfrom .param import PARAM_MAPPINGS, ParamNamespace\nfrom .utils import (\n    Namespace,\n    always_list,\n    logger,\n    parse_potential_argument,\n    parse_type,\n    type_from_value,\n)\n\nif TYPE_CHECKING:\n    from .help import Theme\n    from .param import Param, ParamPath\n\n\nclass Params(Completer):DOCS\n    \"\"\"Params, served as root params or subcommands\n\n    Args:\n        names: The names of this command if served as a command\n        desc: The description of the command.\n            This will be finally compiled into a list if a string is given.\n            The difference is, when displayed on help page, the string will\n            be wrapped by textwrap automatically. However, each element in\n            a given list will not be wrapped.\n        prog: The program name\n        help_keys: The names to bring up the help information\n        help_cmds: The help command names to show help of other\n            subcommands\n        help_on_void: Whether to show help when no arguments provided\n        help_callback: A function to modify the help page\n        help_modifier: A callback function to modify the help param/command\n        prefix: The prefix for the arguments\n            (see attribute `Params.prefix`)\n        arbitrary: Whether to parse the command line arbitrarily\n        theme (str|rich.theme.Theme): The theme to render the help page\n        usage: Some example usages\n\n    Attributes:\n        desc: The description of the command.\n        prog: The program name. Default: `sys.argv[0]`\n        help_keys: The names to bring up the help information.\n        help_cmds: The names of help subcommands to bring up\n            help information of subcommands\n        help_on_void: Whether show help when there is not arguments\n            provided\n        usage: The usages of this program\n        prefix: The prefix for the arguments on command line\n            - `auto`: Automatically determine the prefix for each argument.\n                Basically, `-` for short options, and `--` for long.\n                Note that `-` for `-vvv` if `v` is a count option\n        arbitrary: Whether parsing the command line arbitrarily\n        theme (rich.theme.Theme|str): The theme for the help page\n        names: The names of the commands if this serves as sub-command\n        params: The ordered dict of registered parameters\n        commands: The ordered dict of registered commands\n        param_groups: The ordered dict of parameter groups\n        command_groups: The ordered dict of command groups\n        asssembler: The asssembler to assemble the help page\n    \"\"\"\n\n    def __init__(\n        self,\n        names: Union[str, List[str]] = None,\n        desc: Union[List[str], str] = None,\n        prog: str = None,\n        help_keys: Union[str, List[str]] = None,\n        help_cmds: Union[str, List[str]] = None,\n        help_on_void: Union[str, bool] = None,\n        help_callback: Callable = None,\n        help_modifier: Callable = None,\n        fullopt_keys: Union[str, List[str]] = None,\n        prefix: str = \"auto\",\n        arbitrary: Union[str, bool] = False,\n        theme: Union[str, \"Theme\"] = \"default\",\n        usage: Union[str, List[str]] = None,\n    ) -&gt; None:\n        self.names: List[str] = always_list(names) if names else []\n        self.desc: List[str] = (\n            PARAMS_DEFAULT.desc\n            if desc is None\n            else always_list(desc, strip=False, split=False)\n        )\n        self._prog: str = Path(sys.argv[0]).name if prog is None else prog\n        self.help_keys: List[str] = (\n            PARAMS_DEFAULT.help_keys\n            if help_keys is None\n            else always_list(help_keys)\n        )\n        self.fullopt_keys: List[str] = (\n            PARAMS_DEFAULT.fullopt_keys\n            if fullopt_keys is None\n            else always_list(fullopt_keys)\n        )\n        self.help_cmds: List[str] = (\n            PARAMS_DEFAULT.help_cmds\n            if help_cmds is None\n            else always_list(help_cmds)\n        )\n        self.help_on_void: bool = (\n            PARAMS_DEFAULT.help_on_void\n            if help_on_void is None\n            else help_on_void\n        )\n        self.usage = (\n            None\n            if usage is None\n            else always_list(usage, strip=True, split=\"\\n\")\n        )\n        self.prefix = prefix\n        self.arbitrary = arbitrary\n        self.theme = theme\n\n        self.params = OrderedDiot()\n        self.commands = OrderedDiot()\n\n        self.param_groups = OrderedDiot()\n        self.command_groups = OrderedDiot()\n\n        self.help_modifier = help_modifier\n\n        self.assembler = HelpAssembler(self.prog, theme, help_callback)\n\n        self.has_hidden = False\n        super().__init__()\n\n    @propertyDOCS\n    def prog(self) -&gt; str:\n        \"\"\"Get the program name\"\"\"\n        return self._prog\n\n    @prog.setter\n    def prog(self, value: str):\n        \"\"\"Set the program name and update the help assembler\n\n        Args:\n            value: The new program name\n        \"\"\"\n        self._prog = value\n        self.assembler.console.meta.prog = value\n        self.assembler.console.meta.highlighters.prog = ProgHighlighter(value)\n\n    def name(self, which: str = \"short\") -&gt; str:DOCS\n        \"\"\"Get the shortest/longest name of the parameter\n\n        A name is ensured to be returned. It does not mean it is the real\n        short/long name, but just the shortest/longest name among all the names\n\n        Args:\n            which: Whether get the shortest or longest name\n                Could use `short` or `long` for short.\n\n        Returns:\n            The shortest/longest name of the parameter\n        \"\"\"\n        if not self.names:\n            return None\n        return list(sorted(self.names, key=len))[0 if \"short\" in which else -1]\n\n    def namestr(self, sep: str = \", \") -&gt; str:DOCS\n        \"\"\"Get all names connected with a separator.\n\n        Args:\n            sep: The separator to connect the names\n\n        Returns:\n            the connected names\n        \"\"\"\n        return sep.join(sorted(self.names, key=len))\n\n    def get_param(self, name: str) -&gt; \"Param\":DOCS\n        \"\"\"Get the parameter by name\n\n        If the parameter is under a namespace, try to get it via the namespace\n\n        Args:\n            name: The name of the parameter to get (without prefix)\n\n        Returns:\n            The parameter, None if failed\n        \"\"\"\n        if name is None:\n            return None\n        if \".\" not in name:\n            return self.params.get(name)\n\n        ns_param: \"ParamNamespace\" = self.params.get(name.split(\".\", 1)[0])\n        if not ns_param:\n            return None\n        ret = ns_param.get_param(name)\n        return None if ret is None or name not in ret.names else ret\n\n    def get_command(self, name: str) -&gt; \"Params\":DOCS\n        \"\"\"Get the command object\n\n        Args:\n            name: The name of the command to get\n\n        Returns:\n            The command object, None if failed.\n        \"\"\"\n        return self.commands.get(name)\n\n    def _set_param(self, param: \"Param\") -&gt; None:\n        \"\"\"Set the parameter\n\n        When a paraemeter's type is overwritten, we need to replace it with\n        the new one in the pool (either self.params or the namespace parameter\n        that holds it).\n        \"\"\"\n        if param.namespaces(0):\n            param.ns_param.push(param, -1)\n        else:\n            for name in param.names:\n                self.params[name] = param\n\n    def add_param(DOCS\n        self,\n        names: Union[str, List[str], \"Param\"],\n        default: Any = None,\n        type: Union[str, Type] = None,\n        desc: Union[str, List[str]] = None,\n        show: bool = None,\n        required: bool = None,\n        callback: Callable = None,\n        group: str = None,\n        force: bool = False,\n        type_frozen: bool = None,\n        argname_shorten: bool = None,\n        complete_callback: Callable = None,\n        **kwargs,\n    ) -&gt; \"Param\":\n        \"\"\"Add an argument\n\n        Args:\n            names: names of the argument or a parameter defined somewhere else\n                For example, in case we want to reuse a parameter\n                ```python\n                param = cmd1.add_param('n,name')\n                # reuse it:\n                cmd2.add_param(param)\n                # other arguments will be ignored, except force\n                ```\n\n            default: The default value for the argument\n            type: The type of the argument\n                Including single value type and complex one\n                - Single value types:\n                    auto, int, str, float, bool, count, py, json, reset\n                - Complex value types:\n                    list[&lt;single value type&gt;], ns\n            desc: The description of the argument\n                This will be finally compiled into a list if a string is given.\n                The difference is, when displayed on help page, the string will\n                be wrapped by textwrap automatically. However, each element in\n                a given list will not be wrapped.\n            show: Whether this should be shown on help page.\n            required: Whether this argument is required from\n                the command line\n            callback: Callback to convert parsed values\n            group: The group this parameter belongs to.\n                Arguments will be grouped by this on the help page.\n            force: Whether to force adding parameter if it exists\n            type_frozen: Whether allow type overwritting from\n                the commone line\n            argname_shorten: Whether show shortened name for parameter\n                under namespace parameter\n            complete_callback: The callback for complete the values of the\n                parameter\n            **kwargs: Additional keyword arguments\n\n        Raises:\n            PyParamNameError: When parameter exists and force is false\n\n        Return:\n            Param: The added parameter\n        \"\"\"\n        if isinstance(names, (str, list)):\n            names: List[str] = always_list(names)\n            if type is None:\n                if POSITIONAL in names and default is None:\n                    type = \"list\"\n                else:\n                    type = type_from_value(default)\n\n            maintype, subtype = parse_type(\n                type.__name__\n                if callable(type)\n                else PARAM_DEFAULT.type\n                if type is None\n                else type\n            )\n            show = PARAM_DEFAULT.show if show is None else show\n            if not show:\n                self.has_hidden = True\n\n            param = PARAM_MAPPINGS[maintype](  # type: ignore\n                names=names,\n                default=PARAM_DEFAULT.default if default is None else default,\n                desc=PARAM_DEFAULT.desc\n                if desc is None\n                else always_list(desc, strip=False, split=False),\n                prefix=self.prefix,\n                show=show,\n                required=(\n                    PARAM_DEFAULT.required if required is None else required\n                ),\n                subtype=subtype,\n                type_frozen=(\n                    PARAM_DEFAULT.type_frozen\n                    if type_frozen is None\n                    else type_frozen\n                ),\n                callback=callback,\n                argname_shorten=(\n                    PARAM_DEFAULT.argname_shorten\n                    if argname_shorten is None\n                    else argname_shorten\n                ),\n                complete_callback=complete_callback,\n                **kwargs,\n            )\n        else:\n            param = names.copy()\n\n        if any(name in self.help_keys for name in param.names):\n            param.is_help = True\n        if any(name in self.fullopt_keys for name in param.names):\n            param.is_help = param.is_full = True\n\n        if param.namespaces(0):\n            # add namespace parameter automatically\n            if param.namespaces(0)[0] not in self.params:  # type: ignore\n                self.add_param(param.namespaces(0), type=\"ns\")  # type: ignore\n\n            ns_param: \"ParamNamespace\" = self.params[\n                param.namespaces(0)[0]\n            ]  # type: ignore\n            ns_param.push(param)\n\n        else:\n            for name in param.names:\n                # check if parameter has been added\n                if not force and (\n                    (name in self.params and self.params[name] is not param)\n                    or name in self.commands\n                ):\n                    raise PyParamNameError(\n                        f\"Argument {name!r} has already been added.\"\n                    )\n                self.params[name] = param\n\n        group = group or param.default_group\n        # leave the parameters here under namespace to have flexibility\n        # assigning different groups\n        groups: List[\"Param\"] = self.param_groups.setdefault(group, [])\n\n        # any parameter with param.names hasn't been added\n        if not any(set(param.names) &amp; set(prm.names) for prm in groups):\n            groups.append(param)\n        return param\n\n    def add_command(DOCS\n        self,\n        names: Union[\"Params\", str, List[str]],\n        desc: Union[str, List[str]] = \"No description\",\n        help_keys: Union[str, List[str]] = \"__inherit__\",\n        help_cmds: Union[str, List[str]] = \"__inherit__\",\n        help_on_void: Union[str, bool] = \"__inherit__\",\n        help_callback: Callable = None,\n        help_modifier: Callable = None,\n        prefix: str = \"__inherit__\",\n        arbitrary: Union[str, bool] = \"__inherit__\",\n        theme: Union[str, rich.theme.Theme] = \"__inherit__\",\n        usage: Union[str, List[str]] = None,\n        group: str = None,\n        force: bool = False,\n    ) -&gt; \"Params\":\n        \"\"\"Add a sub-command\n\n        Args:\n            names: list of names of this command\n                It can also be a Params object that served as a subcommand\n            desc: description of this command\n            help_keys: help key for bring up help for this command\n            help_cmds: help command for printing help for other\n                sub-commands of this command\n            help_on_void: whether printing help when no arguments passed\n            help_callback: callback to manipulate help page\n            prefix: prefix for arguments for this command\n            arbitray: whether do arbitray Parsing\n            theme: The theme of help page for this command\n            usage: Usage for this command\n            group: Group of this command\n            force: Force adding when command exists already.\n\n        Returns:\n            The added command\n        \"\"\"\n        command: \"Params\" = None\n        if isinstance(names, Params):\n            command = names\n            command.prog = (\n                f\"{self.prog}{' [OPTIONS]' if self.params else ''} \"\n                f\"{command.name('long')}\"\n            )\n        else:\n            names: List[str] = always_list(names)\n            command: \"Params\" = Params(\n                desc=desc,\n                prog=(\n                    f\"{self.prog}{' [OPTIONS]' if self.params else ''} \"\n                    f\"{sorted(names, key=len)[-1]}\"\n                ),\n                help_keys=(\n                    self.help_keys if help_keys == \"__inherit__\" else help_keys\n                ),\n                help_cmds=(\n                    self.help_cmds if help_cmds == \"__inherit__\" else help_cmds\n                ),\n                help_on_void=(\n                    self.help_on_void\n                    if help_on_void == \"__inherit__\"\n                    else help_on_void\n                ),\n                help_callback=help_callback,\n                help_modifier=help_modifier,\n                prefix=(self.prefix if prefix == \"__inherit__\" else prefix),\n                arbitrary=(\n                    self.arbitrary if arbitrary == \"__inherit__\" else arbitrary\n                ),\n                theme=(self.theme if theme == \"__inherit__\" else theme),\n                usage=usage,\n                names=names,\n            )\n        for cmd in command.names:\n            # check if command has been added\n            if not force and (cmd in self.params or cmd in self.commands):\n                raise PyParamNameError(\n                    f\"Command {cmd!r} has already been added.\"\n                )\n            self.commands[cmd] = command\n\n        group = group or \"COMMANDS\"\n        groups: List[\"Params\"] = self.command_groups.setdefault(group, [])\n\n        if not any(set(command.names) &amp; set(cmd.names) for cmd in groups):\n            groups.append(command)\n        return command\n\n    def print_help(self, exit_code: int = 1, full: bool = False) -&gt; None:DOCS\n        \"\"\"Print the help information and exit\n\n        Args:\n            exit_code: The exit code or False to not exit\n        \"\"\"\n        self.assembler.assemble(self, full=full)\n        self.assembler.printout()\n        if exit_code is not False:\n            sys.exit(exit_code)\n\n    def values(DOCS\n        self, namespace: Namespace = None, ignore_errors: bool = False\n    ) -&gt; Namespace:\n        \"\"\"Get a namespace of all parameter name =&gt; value pairs or attach them\n        to the given namespace\n\n        Args:\n            namespace: The namespace for the values to attach to.\n\n        Returns:\n            the namespace with values of all parameter\n                name-value pairs\n        \"\"\"\n        ns_no_callback: Namespace = Namespace()\n        for param_name, param in self.params.items():\n            if param.is_help or param_name in ns_no_callback:\n                continue\n            try:\n                value: Any = param.value\n            except (PyParamTypeError, PyParamValueError) as pve:\n                if not ignore_errors:\n                    logger.error(\"%r: %s\", param.namestr(), pve)\n                    self.print_help()\n            except Exception:  # pragma: no cover\n                if not ignore_errors:\n                    raise\n            else:\n                for name in param.names:\n                    ns_no_callback[name] = value\n\n        if namespace is None:\n            namespace = Namespace()\n\n        for param_name, param in self.params.items():\n            if param.is_help or param_name in namespace:\n                continue\n            try:\n                value: Any = param.apply_callback(ns_no_callback)\n            except (PyParamTypeError, PyParamValueError) as pte:\n                if not ignore_errors:  # pragma: no cover\n                    logger.error(\"%r: %s\", param.namestr(), pte)\n                    self.print_help()\n            except Exception:\n                if not ignore_errors:\n                    raise\n            else:\n                for name in param.names:\n                    setattr(namespace, name, value)\n        return namespace\n\n    def parse(DOCS\n        self, args: List[str] = None, ignore_errors: bool = False\n    ) -&gt; Namespace:\n        \"\"\"Parse the arguments from the command line\n\n        Args:\n            args: The arguments to parse\n            ignore_errors: Whether to ignore errors.\n                This is helpful to check a specific option or command,\n                but ignore errors, such as required options not provided.\n\n        Return:\n            Namespace: The namespace of parsed arguments\n        \"\"\"\n        # add help options here so that user can disable or\n        # change it before parsing\n        self.add_param(\n            self.help_keys,\n            type=\"bool\",\n            desc=\"Print help information for this command\",\n            force=True,\n        )\n        if self.has_hidden:\n            self.add_param(\n                self.fullopt_keys,\n                type=\"bool\",\n                desc=\"Show full options for this command\",\n                force=True,\n            )\n\n        help_cmd: \"Params\" = None\n        if self.commands:\n            help_cmd = self.add_command(\n                self.help_cmds, desc=\"Print help of sub-commands\", force=True\n            )\n            help_cmd.add_param(\n                POSITIONAL,\n                type=\"choice\",\n                default=\"\",\n                desc=(\n                    \"Command name to print help for. \"\n                    \"Available commands are: {}\".format(\n                        \", \".join(\n                            cmd\n                            for cmd in self.commands\n                            if cmd not in self.help_cmds\n                        )\n                    )\n                ),\n                choices=list(self.commands),\n            )\n\n        if callable(self.help_modifier):\n            self.help_modifier(self.get_param(self.help_keys[0]), help_cmd)\n\n        if args is None:\n            # enable completion only when we are trying to parse sys.argv\n            if self.comp_shell:\n                print(\"\\n\".join(self.complete()))\n                sys.exit(0)\n            args = sys.argv[1:]\n\n        if not args and self.help_on_void:\n            self.print_help()\n\n        namespace: Namespace = Namespace()\n        self._parse(args, namespace, ignore_errors)\n\n        # # Allow command to be not provided.\n        # if self.commands and not namespace.__command__:\n        #     logger.error('No command given.')\n        #     self.print_help()\n        # run help subcommand\n        if (\n            namespace.__command__ in self.help_cmds\n            and len(self.commands) &gt; 1  # together with help command\n        ):\n            command_passed = namespace[namespace.__command__][POSITIONAL]\n            if not command_passed:  # pragma: no cover\n                self.print_help()\n            elif command_passed not in self.commands:  # pragma: no cover\n                logger.error(\"Unknown command: %r\", command_passed)\n                self.print_help()\n            else:\n                self.commands[command_passed].print_help()\n        return namespace\n\n    def _parse(\n        self,\n        args: List[str],\n        namespace: Namespace,\n        ignore_errors: bool,\n    ) -&gt; None:\n        \"\"\"Parse the arguments from the command line\n\n        Args:\n            args: The arguments to parse\n            namespace: The namespace for parsed arguments to\n                attach to.\n        \"\"\"\n        logger.debug(\"Parsing %r\", args)\n\n        if not args:  # help_on_void = False\n            self.values(namespace, ignore_errors)\n            return\n\n        prev_param: \"Param\" = None\n        for i, arg in enumerate(args):\n            logger.debug(\"- Parsing item %r\", arg)\n            # Match the arg with defined parameters\n            # If arbitrary, non-existing parameters will be created on the fly\n            # This means\n            # 1. if param_name is None\n            #    arg is not a parameter-like format (ie. -a, --arg)\n            #    then param_value == arg\n            # 2. if param_name is not None, arg is parameter-like\n            #    With arbitrary = True, parameter will be created on the fly\n            # 3. if arg is like --arg=1, then param_value 1 is pushed to param.\n            param, param_name, param_type, param_value = self._match_param(arg)\n            logger.debug(\"  Previous: %r\", prev_param)\n            logger.debug(\n                \"  Matched: %r, name=%s, type=%s, value=%r\",\n                param,\n                param_name,\n                param_type,\n                param_value,\n            )\n            # as long as the help argument hit\n            if (\n                param_name in self.help_keys\n                or param_name in self.fullopt_keys\n                or (param and param.is_help)\n            ):\n                self.print_help(\n                    full=param_name in self.fullopt_keys\n                    or (param and param.is_full)\n                )\n\n            if param:\n                if prev_param:\n                    logger.debug(\"  Closing previous argument\")\n                    prev_param.close()\n                prev_param = param\n\n            elif prev_param:  # No param\n                if param_name is not None:\n                    if not ignore_errors:\n                        logger.warning(\"Unknown argument: %r, skipped\", arg)\n                elif not prev_param.consume(param_value):\n                    # If value cannot be consumed, let's see if it\n                    # 1. hits a command\n                    # 2. hits the start of positional arguments\n                    prev_param.close()\n                    prev_param, matched = self._match_command_or_positional(\n                        prev_param,\n                        param_value,\n                        args[(i + 1) :],\n                        namespace,\n                        ignore_errors,\n                    )\n                    if matched == \"command\":\n                        break\n                    if matched == \"positional\":\n                        continue\n                    if param_value is not None and not ignore_errors:\n                        logger.warning(\n                            \"Unknown value: %r, skipped\", param_value\n                        )\n                else:\n                    logger.debug(\n                        \"  Param %r consumes %r\",\n                        prev_param.namestr(),\n                        param_value,\n                    )\n            else:  # neither\n                prev_param, matched = self._match_command_or_positional(\n                    prev_param,\n                    param_value,\n                    args[(i + 1) :],\n                    namespace,\n                    ignore_errors,\n                )\n                if matched == \"command\":\n                    break\n                if matched == \"positional\":\n                    continue\n                if param_value is not None and not ignore_errors:\n                    logger.warning(\"Unknown value: %r, skipped\", param_value)\n\n        if prev_param:\n            logger.debug(\"  Closing final argument: %r\", prev_param.namestr())\n            prev_param.close()\n\n        self.values(namespace, ignore_errors)\n\n    def _match_command_or_positional(\n        self,\n        prev_param: \"Param\",\n        arg: str,\n        rest_args: List[str],\n        namespace: Namespace,\n        ignore_errors: bool = False,\n    ) -&gt; Tuple[\"Param\", str]:\n        \"\"\"Check if arg hits a command or a positional argument start\n\n        Args:\n            prev_param: The previous parameter\n            arg: The current argument item\n            rest_args: The remaining argument items\n\n        Returns:\n            tuple (Param, str):\n                - A parameter if we create a new one here\n                    (ie, a positional parameter)\n                - 'command' when arg hits a command or 'positional' when it\n                    hits the start of a positional argument. Otherwise, None.\n        \"\"\"\n        if prev_param and prev_param.is_positional:\n            logger.debug(\"  Hit positional argument\")\n            prev_param.push(arg)\n            return prev_param, \"positional\"\n\n        if arg not in self.commands:\n            # any of the rest args matches is argument-like then\n            # this should not hit the start of positional argument\n            for rest_arg in rest_args:\n                if self.prefix != \"auto\" and rest_arg.startswith(self.prefix):\n                    break\n\n                if self.prefix == \"auto\" and rest_arg[:1] == \"-\":\n                    if len(rest_arg) &lt;= 2 or (\n                        rest_arg[:2] == \"--\" and len(rest_arg) &gt; 3\n                    ):\n                        break\n            else:\n                logger.debug(\"  Hit start of positional argument\")\n                if self.arbitrary and POSITIONAL not in self.params:\n                    self.add_param(POSITIONAL)\n                if POSITIONAL in self.params:\n                    self.params[POSITIONAL].hit = True\n                    self.params[POSITIONAL].push(arg)\n                    return self.params[POSITIONAL], \"positional\"\n\n        if prev_param:\n            prev_param.close()\n\n        if self.arbitrary and arg not in self.commands:\n            self.add_command(arg)\n\n        if arg not in self.commands:\n            return None, None\n\n        logger.debug(\"* Hit command: %r\", arg)\n        command: \"Params\" = self.commands[arg]\n        namespace.__command__ = arg\n        parsed: Namespace = command.parse(rest_args, ignore_errors)\n        for name in command.names:\n            namespace[name] = parsed\n\n        return None, \"command\"\n\n    def _match_param(self, arg: str) -&gt; Tuple[\"Param\", str, str, str]:\n        \"\"\"Check if arg matches any predefined parameters. With\n        arbitrary = True, parameters will be defined on the fly.\n\n        And then do all the preparation for the matched parameter, including\n        overwrite the type and push the attached value, such as '--arg=1'\n\n        Args:\n            arg: arg to check\n\n        Returns:\n            The matched parameter, parameter name,\n                type and unpushed value if matched.\n                Otherwise, None, param_name, param_type and arg itself.\n        \"\"\"\n        param_name, param_type, param_value = parse_potential_argument(\n            arg, self.prefix\n        )\n        # parse -arg as -a rg only applicable with prefix auto and -\n        # When we didn't match any argument-like\n        # with allow_attached=False\n        # Or we matched but it is not defined\n        name_with_attached: str = None\n        if not param_type and self.prefix == \"auto\":\n            # then -a1 will be put in param_value, as if `a1` is a name,\n            # it should be --a1\n            name_with_attached = (\n                param_value\n                if (\n                    param_name is None\n                    and param_value\n                    and param_value[:1] == \"-\"\n                    and param_value[1:2] != \"-\"\n                )\n                else None\n            )\n\n        elif not param_type and len(self.prefix) &lt;= 1:\n            # say prefix = '+'\n            # then `a1` for `+a1` will be put as param_name, since\n            # there is no restriction on name length\n            name_with_attached = (\n                self.prefix + param_name\n                if param_name and param_name[:1] != self.prefix\n                else None\n            )\n\n        # we cannot find a parameter with param_name\n        # check if there is any value attached\n        if name_with_attached and not self.get_param(param_name):\n            param_name2, param_type2, param_value2 = parse_potential_argument(\n                name_with_attached, self.prefix, allow_attached=True\n            )\n            # Use them only if we found a param_name2 and\n            # arbitrary: not previous param_name found\n            # otherwise: parameter with param_name2 exists\n            if param_name2 is not None and (\n                (self.arbitrary and param_name is None)\n                or self.get_param(param_name2)\n            ):\n                param_name, param_type, param_value = (\n                    param_name2,\n                    param_type2,\n                    param_value2,\n                )\n\n        # create the parameter for arbitrary\n        if (\n            self.arbitrary\n            and param_name is not None\n            and not self.get_param(param_name)\n        ):\n            self.add_param(param_name, type=param_type)\n\n        param: \"Param\" = self.get_param(param_name)\n        if not param:\n            return None, param_name, param_type, param_value\n\n        param_maybe_overwritten: \"Param\" = param.overwrite_type(param_type)\n        if param_maybe_overwritten is not param:\n            self._set_param(param_maybe_overwritten)\n            param = param_maybe_overwritten\n\n        param.hit = True\n        if param_value is not None:\n            param.push(param_value)\n        return param, param_name, param_type, param_value\n\n    def _all_params(self, show_only=False) -&gt; List[\"Param\"]:\n        \"\"\"All parameters under this command\n\n        self.params don't have all of them, since namespaced ones are under\n        namespace paramters\n        \"\"\"\n        ret: List[\"Param\"] = []\n        ret_append: Callable = ret.append\n        for param in self.params.values():\n            if param.type == \"ns\":\n                if (not show_only or param.show) and param not in ret:\n                    ret.append(param)\n                ret.extend(param.decendents(show_only))\n\n            elif show_only and not param.show:\n                continue\n            elif param not in ret:\n                ret_append(param)\n        return ret\n\n    def _to_dict_params(self) -&gt; Diot:\n        \"\"\"Load all parameters into a dictionary\"\"\"\n        ret = Diot()\n        param_groups = {}\n        for group, param_list in self.param_groups.items():\n            for param in param_list:\n                param_groups[param.names[0]] = group\n\n        for param in self._all_params():\n            param_name: str = (\n                \"POSITIONAL\"\n                if param.names[0] == POSITIONAL\n                else param.names[0]\n            )\n            ret[param_name] = Diot()\n            param_dict: Diot = ret[param_name]\n            if len(param.names) &gt; 1:\n                param_dict.aliases = [\n                    \"POSITIONAL\" if name == POSITIONAL else name\n                    for name in param.names[1:]\n                ]\n            if param.default != PARAM_DEFAULT.default:\n                param_dict.default = param.default\n            if param.typestr() != PARAM_DEFAULT.type:\n                param_dict.type = param.typestr()\n            if param.desc != PARAM_DEFAULT.desc:\n                param_dict.desc = param.desc\n            if param.show != PARAM_DEFAULT.show:\n                param_dict.show = param.show\n            if param.required != PARAM_DEFAULT.required:\n                param_dict.required = param.required\n            if param.type_frozen != PARAM_DEFAULT.type_frozen:\n                param_dict.type_frozen = param.type_frozen\n            if param.argname_shorten != PARAM_DEFAULT.argname_shorten:\n                param_dict.argname_shorten = param.argname_shorten\n            param_dict.group = group = param_groups[param.names[0]]\n            param_dict |= param._kwargs\n\n        return ret\n\n    def _to_dict_commands(self) -&gt; Diot:\n        \"\"\"Load all commands into a dictionary\"\"\"\n        ret = Diot()\n        command_groups = {}\n        for group, command_list in self.command_groups.items():\n            for command in command_list:\n                for name in command.names:\n                    command_groups[name] = group\n\n        for command_name, command in self.commands.items():\n            if any(name in ret for name in command.names):\n                continue\n            ret[command_name] = Diot()\n            cmd_dict: Diot = ret[command_name]\n            if len(command.names) &gt; 1:\n                cmd_dict.aliases = [\n                    name for name in command.names if name != command_name\n                ]\n            if command.desc != PARAMS_DEFAULT.desc:\n                cmd_dict.desc = command.desc\n            if command.help_keys != PARAMS_DEFAULT.help_keys:\n                cmd_dict.help_keys = command.help_keys\n            if command.help_cmds != PARAMS_DEFAULT.help_cmds:\n                cmd_dict.help_cmds = command.help_cmds\n            if command.help_on_void != PARAMS_DEFAULT.help_on_void:\n                cmd_dict.help_on_void = command.help_on_void\n            if command.prefix != PARAMS_DEFAULT.prefix:\n                cmd_dict.prefix = command.prefix\n            if command.arbitrary != PARAMS_DEFAULT.arbitrary:\n                cmd_dict.arbitrary = command.arbitrary\n            if command.theme != PARAMS_DEFAULT.theme:\n                cmd_dict.theme = command.theme\n            if command.usage != PARAMS_DEFAULT.usage:\n                cmd_dict.usage = command.usage\n            cmd_dict.group = command_groups[command_name]\n            cmd_dict |= command.to_dict()\n\n        return ret\n\n    def to_dict(self) -&gt; Diot:DOCS\n        \"\"\"Save the parameters/commands to file.\n\n        This is helpful if the parameters/commands take time to load. Once can\n        cache this to a file, and load it from it using `from_file`.\n\n        Returns:\n            The complied Diot of parameters and commands\n        \"\"\"\n        # load all parameters and commands\n        return Diot(\n            params=self._to_dict_params(), commands=self._to_dict_commands()\n        )\n\n    def to_file(self, path: Union[str, Path], cfgtype: str = None) -&gt; None:DOCS\n        \"\"\"Save the parameters/commands to file.\n\n        This is helpful if the parameters/commands take time to load. Once can\n        cache this to a file, and load it from it using `from_file`.\n\n        Args:\n            path: The path to the file\n            cfgtype: The type of the file\n                If not given, will inferred from the suffix of the path\n                Supports one of yaml, toml and json\n        \"\"\"\n        loaded: Diot = self.to_dict()\n        if not isinstance(path, Path):\n            path = Path(path)\n        if not cfgtype:\n            if path.suffix in (\".yml\", \".yaml\"):\n                cfgtype = \"yaml\"\n            elif path.suffix == \".toml\":\n                cfgtype = \"toml\"\n            elif path.suffix == \".json\":\n                cfgtype = \"json\"\n            else:\n                cfgtype = path.suffix\n        if cfgtype not in (\"yaml\", \"json\", \"toml\"):\n            raise ValueError(\"File type not supported: %s\" % cfgtype)\n\n        if cfgtype == \"yaml\":\n            loaded.to_yaml(path)\n        elif cfgtype == \"json\":\n            loaded.to_json(path)\n        else:\n            loaded.to_toml(path)\n\n    def from_file(DOCS\n        self,\n        filename: Union[str, PathLike, dict],\n        show: bool = True,\n        force: bool = False,\n    ) -&gt; None:\n        \"\"\"Load parameters from file\n\n        We support 2 types for format to load the parameters.\n\n        - express way, which has some limitations:\n            1. no command definition;\n            2. no namespace parameters;\n        ```toml\n        arg = 1 # default value\n        \"arg$desc\" = \"An argument\" # description\n        # other attributes\n        ```\n\n        - full specification\n        ```toml\n        [params.arg]\n        default = 1\n        desc = \"An argument\"\n        [commands.command]\n        desc = \"A subcommand\"\n\n          [commands.command.params.arg]\n          default = 2\n          desc = \"An argument for command\"\n        ```\n\n        Args:\n            filename: path to the file\n            filetype: The type of the file. If None, will infer from the\n                filename. Supported types: ini, cfg, conf, config, yml, yaml,\n                json, env, osenv, toml\n            show: The default show value for parameters in the file\n            force: Whether to force adding params/commands\n        \"\"\"\n        config = Config.load(filename)\n        self.from_dict(config, show=show, force=force)\n\n    def _from_dict_with_sections(\n        self,\n        dict_obj: Dict[str, Dict[str, dict]],\n        show: bool = True,\n        force: bool = False,\n    ) -&gt; None:\n        \"\"\"Load from the dict with 'params' and/or 'commands' sections\"\"\"\n\n        param_section: Dict[str, dict] = dict_obj.get(\"params\", {})\n        # Type: str, dict\n        for param_name, param_attrs in param_section.items():\n            param_attrs.setdefault(\"show\", show)\n            names: List[str] = always_list(param_attrs.pop(\"aliases\", []))\n            names.insert(0, param_name)\n            self.add_param(\n                [\n                    POSITIONAL if name == \"POSITIONAL\" else name\n                    for name in names\n                ],\n                **param_attrs,\n                force=force,\n            )\n\n        command_section: Dict[str, dict] = dict_obj.get(\"commands\", {})\n        for command_name, command_attrs in command_section.items():\n            names: List[str] = always_list(command_attrs.pop(\"aliases\", []))\n            names.insert(0, command_name)\n            param_section: Dict[str, dict] = command_attrs.pop(\"params\", {})\n            subcmd_section: Dict[str, dict] = command_attrs.pop(\"commands\", {})\n            command: \"Params\" = self.add_command(\n                names, **command_attrs, force=force\n            )\n            command.from_dict(\n                {\"params\": param_section, \"commands\": subcmd_section}, show\n            )\n\n    def _express_to_full_dict(\n        self,\n        expr_dict: dict,\n        ns_key: str = None,\n    ) -&gt; dict:\n        \"\"\"Convert express dict to full dict specification\"\"\"\n        full_dict = {\n            (\n                (ns_key + \".\" if ns_key else \"\")\n                + (key if \".\" not in key else key.split(\".\", 1)[0])\n            ): {}\n            for key in expr_dict\n        }\n        for key, val in expr_dict.items():\n            nskey = f\"{ns_key}.{key}\" if ns_key else key\n            if nskey in full_dict:\n                param = self.get_param(nskey)\n                if isinstance(param, ParamNamespace):\n                    del full_dict[nskey]\n                    if not isinstance(val, dict):\n                        raise ValueError(\n                            f\"Value for namespace parameter `{nskey}` \"\n                            \"must be a dict.\"\n                        )\n\n                    full_dict.update(\n                        self._express_to_full_dict(val, nskey)\n                    )\n                else:\n                    full_dict[nskey][\"default\"] = val\n\n            else:\n                param_name, _, param_attr = key.rpartition(\".\")\n                full_dict[param_name][param_attr] = val\n\n        return full_dict\n\n    def from_dict(DOCS\n        self,\n        dict_obj: dict,\n        show: bool = True,\n        force: bool = False,\n    ):\n        \"\"\"Load parameters from python dict\n\n        Args:\n            dict_obj: A python dictionary to load parameters from\n            show: The default show value for the parameters in the\n                dictionary\n            force: Whether to force adding params/commands\n        \"\"\"\n        if \"params\" not in dict_obj and \"commands\" not in dict_obj:\n            # express way\n            # scan and create dict for all params\n            dict_obj = self._express_to_full_dict(dict_obj)\n            dict_obj = {\"params\": dict_obj}\n\n        self._from_dict_with_sections(dict_obj, show, force)\n\n    def from_arg(DOCS\n        self,\n        names: Union[str, List[str], \"ParamPath\"],\n        desc: Union[str, List[str]] = \"The configuration file.\",\n        group: str = None,\n        default: Union[str, Path] = None,\n        show: bool = True,\n        force: bool = False,\n        args: List[str] = None,\n    ):\n        \"\"\"Load parameters from the file specified by naargument\n        from command line\n\n        This will load the parameters from the file given by the argument,\n        ignoring other arguments from the command line. One can overwrite\n        some of them afterwards, and do the parsing finally.\n\n        Args:\n            names: The names of the parameter or\n                the parameter itself. If it is the parameter, other\n                arguments are ignored\n            desc: The description of the parameter\n            group: The group of the parameter\n            default: The default value of the file path\n            show: Whether those parameters should show up in the help page\n            force: Whether to force adding the parameters/commands\n            args: The list of items to parse, otherwise\n                parse sys.argv[1:]\n        \"\"\"\n        if isinstance(names, (str, list)):\n            param: \"Param\" = self.add_param(\n                names, desc=desc, group=group, type=\"path\", default=default\n            )\n        else:\n            param: \"Param\" = names\n            self._set_param(names)\n\n        prefixed_names: List[str] = [\n            param._prefix_name(name) for name in param.names\n        ]\n        args: List[str] = sys.argv[1:] if args is None else args\n        args_with_the_arg: List[str] = []\n        for i, arg in enumerate(args):\n            if arg in prefixed_names:\n                args_with_the_arg.append(arg)\n                if i &lt; len(args) - 1:\n                    args_with_the_arg.append(args[i + 1])\n                break\n        filepath: Union[str, Path] = (\n            args_with_the_arg[1] if len(args_with_the_arg) &gt; 1 else param.value\n        )\n        if filepath:\n            self.from_file(filepath, show=show, force=force)\n\n    def __repr__(self):\n        return \"&lt;Params(%s) @ %s&gt;\" % (\",\".join(self.names), id(self))\n\n    def copy(self, deep=False) -&gt; \"Params\":DOCS\n        \"\"\"Copy a Params object\n\n        Args:\n            deep: Whether to copy the parameters and commands deeply\n\n        Returns:\n            The copied params object\n        \"\"\"\n        copied: \"Params\" = Params(\n            names=self.names[:],\n            desc=self.desc[:],\n            prog=self.prog,\n            help_keys=self.help_keys[:],\n            help_cmds=self.help_cmds[:],\n            help_on_void=self.help_on_void,\n            help_callback=None,\n            help_modifier=self.help_modifier,\n            prefix=self.prefix,\n            arbitrary=self.arbitrary,\n            theme=self.theme,\n            usage=self.usage and self.usage[:],\n        )\n        copied.assembler = self.assembler\n\n        if not deep:\n            copied.params = self.params.copy()\n            copied.commands = self.commands.copy()\n\n            copied.param_groups = self.param_groups.copy()\n            copied.command_groups = self.command_groups.copy()\n        else:\n            copied.params = OrderedDiot()\n            copied.commands = OrderedDiot()\n\n            copied.param_groups = OrderedDiot()\n            copied.command_groups = OrderedDiot()\n\n            for param in self.params.values():\n                if any(name in copied.params for name in param.names):\n                    continue\n                param_copy = param.copy()\n                for name in param.names:\n                    copied.params[name] = param_copy\n\n            for command in self.commands.values():\n                if any(name in copied.commands for name in command.names):\n                    continue\n                command_copy = command.copy(deep=deep)\n                for name in command.names:\n                    copied.commands[name] = command_copy\n\n            for group, param_list in self.param_groups.items():\n                self.param_groups[group] = [\n                    copied.get_param(param.names[0]) for param in param_list\n                ]\n            for group, cmd_list in self.command_groups.items():\n                self.command_groups[group] = [\n                    copied.commands[cmd.names[0]] for cmd in cmd_list\n                ]\n\n        return copied\n</code></pre>"},{"location":"api/source/pyparam.utils/","title":"pyparam.utils","text":""},{"location":"api/source/pyparam.utils/","title":"SOURCE CODE pyparam.utils DOCS","text":"<pre><code>\"\"\"Utilities for pyparam\n\nAttributes:\n    logger: The logger\n\"\"\"\nimport ast\nimport builtins\nimport json\nimport logging\nfrom argparse import Namespace as APNamespace\nfrom functools import lru_cache\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nfrom rich.console import Console\nfrom rich.logging import RichHandler as _RichHandler\nfrom rich.padding import Padding\nfrom rich.syntax import Syntax\nfrom rich.text import Text\n\nfrom .defaults import TYPE_NAMES\nfrom .exceptions import PyParamTypeError\n\n\nclass Namespace(APNamespace):DOCS\n    \"\"\"Subclass of `argparse.Namespace`\n\n    We have enabled `__getitem__`, `__setitem__`, `__len__` and `__contains__`.\n    So that you can do:\n\n    ```python\n    ns = Namespace()\n    ns['a'] = 1  # same as ns.a = 1\n    ns['a'] == 1 # same as ns.a == 1\n    len(ns) == 1\n    'a' in ns\n    ```\n\n    Attributes:\n        __command__: The command name if matched.\n    \"\"\"\n\n    __command__: str = None\n\n    def __getitem__(self, name: str) -&gt; Any:\n        return getattr(self, name)\n\n    def __setitem__(self, name: str, value: Any) -&gt; None:\n        setattr(self, name, value)\n\n    def __len__(self) -&gt; int:\n        return len(vars(self))\n\n    def __contains__(self, name: str) -&gt; bool:\n        return name in vars(self)\n\n    def __or__(self, other):\n        # copy myself\n        myself: Namespace = self.__class__()\n        myself |= self\n        myself |= other\n        return myself\n\n    def __ior__(self, other):\n        if not isinstance(other, dict):\n            other = vars(other)\n        for key, value in other.items():\n            self[key] = value\n        return self\n\n    def _to_dict(self, dict_wrapper: Type = None) -&gt; Dict:  # pragma: no cover\n        \"\"\"Convert the namespace to a dict object\"\"\"\n        out = {}\n        for key in vars(self):\n            out[key] = self[key]\n        if not dict_wrapper:\n            return out\n        return dict_wrapper(out)\n\n\nclass Codeblock:DOCS\n    \"\"\"A code block, will be rendered as rich.syntax.Syntax\"\"\"\n\n    @classmethodDOCS\n    def scan_texts(\n        cls, texts: List[str], check_default: bool = False\n    ) -&gt; List[Union[str, \"Codeblock\"]]:\n        \"\"\"Scan multiple texts for code blocks\n\n        Args:\n            cls (Codeblock class): The class\n            texts: a list of texts\n            check_default: Check if there is default in maybe_codeblock.\n                Defaults should not be scanned as code blocks\n\n        Returns:\n            mixed text and code blocks\n        \"\"\"\n\n        ret: List[Union[str, \"Codeblock\"]] = []\n        ret_extend: Callable = ret.extend\n        codeblock: \"Codeblock\" = None\n        # Type: Union[str, Codeblock]\n        for text in texts:\n            if not codeblock:\n                if not text:\n                    ret.append(text)\n                    continue\n                scanned, codeblock = cls.scan(\n                    text, check_default=check_default\n                )\n                ret_extend(scanned)\n                continue\n            # if we hit an unclosed codeblock\n            lines: List[str] = text.splitlines()\n            # Type: int, str\n            for i, line in enumerate(lines):\n                if codeblock.is_end(line):\n                    scanned, codeblock = cls.scan(\n                        \"\\n\".join(\n                            lines[\n                                (i if codeblock.opentag == \"&gt;&gt;&gt;\" else i + 1) :\n                            ]\n                        ),\n                        check_default=check_default,\n                    )\n                    ret_extend(scanned)\n                    break\n            else:\n                codeblock.add_code(text)\n        return ret\n\n    @classmethodDOCS\n    def scan(\n        cls, maybe_codeblock: str, check_default: bool = False\n    ) -&gt; Tuple[List[Union[str, \"Codeblock\"]], \"Codeblock\"]:\n        \"\"\"Scan and try to create codeblock objects from maybe_codeblock\n\n        Args:\n            cls (Codeblock class): The class\n            maybe_codeblock: Maybe a code block start\n                It can be a text block, we have to scan if it has code blocks\n                inside.\n            check_default: Check if there is default in maybe_codeblock.\n                Defaults should not be scanned as code blocks\n\n        Returns:\n            mixed text and unclosed code blocks\n        \"\"\"\n        sep: str = (\n            \"Default:\"\n            if \"Default:\" in maybe_codeblock\n            else \"DEFAULT:\"\n            if \"DEFAULT:\" in maybe_codeblock\n            else None\n        )\n\n        default_to_append: str = None\n        default_in_newline = False\n        if check_default and sep:\n            parts: List[str] = maybe_codeblock.split(sep, 1)\n            default_to_append = sep + parts[1]\n            default_in_newline = parts[0].endswith(\"\\n\")\n            lines: List[str] = parts[0].splitlines()\n        else:\n            lines: List[str] = maybe_codeblock.splitlines()\n\n        ret: List[Union[str, \"Codeblock\"]] = []\n        ret_append: Callable = ret.append\n        codeblock: \"Codeblock\" = None\n        # Type: str\n        for line in lines:\n            if not codeblock:\n                line_lstripped: str = line.lstrip()\n                if line_lstripped.startswith(\"&gt;&gt;&gt;\"):\n                    codeblock: \"Codeblock\" = cls(\n                        \"&gt;&gt;&gt;\",\n                        \"pycon\",\n                        len(line) - len(line_lstripped),\n                        [line_lstripped],\n                    )\n                    ret_append(codeblock)\n                elif line_lstripped.startswith(\"```\"):\n                    codeblock: \"Codeblock\" = cls(\n                        line_lstripped[\n                            : (\n                                len(line_lstripped)\n                                - len(line_lstripped.lstrip(\"`\"))\n                            )\n                        ],\n                        line_lstripped.lstrip(\"`\").strip() or \"text\",\n                        len(line) - len(line_lstripped),\n                    )\n                    ret_append(codeblock)\n                else:\n                    ret_append(line)\n            elif codeblock.is_end(line):\n                if codeblock.opentag == \"&gt;&gt;&gt;\":\n                    ret.append(line)\n                codeblock = None\n            else:\n                codeblock.add_code(line)\n\n        if default_to_append:\n            # if codeblock (&gt;&gt;&gt;) is not closed.\n            # but we have default so it actually closes\n            if codeblock and codeblock.opentag == \"&gt;&gt;&gt;\":\n                codeblock = None\n            if not ret or isinstance(ret[-1], Codeblock) or default_in_newline:\n                ret.append(default_to_append)\n            else:\n                ret[-1] += default_to_append\n        return ret, codeblock\n\n    def __init__(\n        self,\n        opentag: str,\n        lang: str,\n        indent: int,\n        codes: List[str] = None,\n    ) -&gt; None:\n        \"\"\"Constructor\n\n        Args:\n            opentag: The opentag for the code block.\n                One of '&gt;&gt;&gt;', '```&lt;lang&gt;', '````&lt;lang&gt;', ...\n            lang: The language name\n            indent: The indentation level\n            codes: The lines of code\n        \"\"\"\n        self.opentag: str = opentag\n        self.lang: str = lang\n        self.indent: int = indent\n        self.codes: List[str] = codes or []\n\n    def __repr__(self) -&gt; str:\n        return (\n            f\"&lt;Codeblock (tag={self.opentag}, lang={self.lang}, \"\n            f\"codes={self.codes[:1]} ...)\"\n        )\n\n    def add_code(self, code: str) -&gt; None:DOCS\n        \"\"\"Add code to code block\n\n        Args:\n            code: code to add\n                It can be multiple lines, each of which will be dedented\n        \"\"\"\n        # Type: str\n        for line in code.splitlines():\n            self.codes.append(line[self.indent :])\n\n    def is_end(self, line: str) -&gt; bool:DOCS\n        \"\"\"Tell if the line is the end of the code block\n\n        Args:\n            line: line to check\n\n        Returns:\n            True if it is the end otherwise False\n        \"\"\"\n        if self.opentag == \"&gt;&gt;&gt;\" and not line[self.indent :].startswith(\"&gt;&gt;&gt;\"):\n            return True\n        if (\n            \"`\" in self.opentag\n            and line[self.indent :].rstrip() == self.opentag\n        ):\n            return True\n        return False\n\n    def render(self) -&gt; Padding:DOCS\n        \"\"\"Render the code block to a rich.syntax.Syntax\n\n        Returns:\n            A padding of rich.syntax.Syntax\n        \"\"\"\n        return Padding(\n            Syntax(\"\\n\".join(self.codes), self.lang), (0, 0, 0, self.indent)\n        )\n\n\ndef always_list(DOCS\n    str_or_list: Union[str, List[str]],\n    strip: bool = True,\n    split: Union[str, bool] = \",\",\n) -&gt; List[str]:\n    \"\"\"Convert a string (comma separated) or a list to a list\n\n    Args:\n        str_or_list: string or list\n        strip: whether to strip the elements in result list\n        split: Delimiter for split or False to not split\n\n    Return:\n        list: list of strings\n    \"\"\"\n    if isinstance(str_or_list, (list, tuple)):\n        return list(str_or_list)\n    if split:\n        return [\n            elem.strip() if strip else elem\n            for elem in str_or_list.split(split)  # type: ignore\n        ]\n    return [str_or_list]\n\n\ndef parse_type(typestr: str) -&gt; List[str]:DOCS\n    \"\"\"Parse the type string\n\n    Examples:\n        &gt;&gt;&gt; parse_type(None)    # None, None\n        &gt;&gt;&gt; parse_type(\"array\") # list, None\n        &gt;&gt;&gt; parse_type(\"a:i\")   # list, int\n        &gt;&gt;&gt; parse_type(\"j\")     # json, None\n        &gt;&gt;&gt; parse_type(\"list\")  # list, None\n\n    Args:\n        typestr: string of type to parse\n\n    Returns:\n        Main type and subtype\n\n    Raises:\n        PyParamTypeError: When a type cannot be parsed\n    \"\"\"\n    if typestr is None:\n        return [None, None]\n\n    parts: List[str] = typestr.split(\":\", 1)\n    # Type: int, str\n    for i, part in enumerate(parts):\n        if part not in TYPE_NAMES:\n            raise PyParamTypeError(\"Unknown type: %s\" % typestr)\n        parts[i] = TYPE_NAMES[part]\n\n    parts.append(None)\n    return parts[:2]\n\n\n@lru_cache()DOCS\ndef parse_potential_argument(\n    arg: str, prefix: str, allow_attached: bool = False\n) -&gt; Tuple[str, str, str]:\n    \"\"\"Parse a potential argument with given prefix\n\n    Examples:\n        &gt;&gt;&gt; # prefix == 'auto\n        &gt;&gt;&gt; parse_potential_argument(\"-a\")     # a, None, None\n        &gt;&gt;&gt; parse_potential_argument(\"--arg\")  # arg, None, None\n        &gt;&gt;&gt; parse_potential_argument(\"--a\")    # None, None, a\n        &gt;&gt;&gt; parse_potential_argument(\"-abc\")   # None, None, -abc\n        &gt;&gt;&gt; parse_potential_argument(\"-abc\", allow_attached=True)\n        &gt;&gt;&gt; # -a, None, bc\n\n    Args:\n        arg: a potential argument. Such as:\n            -a, --def, -b=1, --abc=value, -b1 (for argument -b with value 1)\n            with types:\n            -a:int --def:list -b:str=1 --abs:str=value -b:bool\n            It is usually one element of the sys.argv\n        prefix: The prefix for the argument names\n        allow_attached: Whether to detect item like '-b1' for argument\n            '-b' with value '1' or the entire one is parsed as argument '-b1'\n\n    Returns:\n        The argument name, type and value\n            When arg cannot be parsed as an argument, argument name and type\n            will both be None. arg will be returned as argument value.\n    \"\"\"\n    if not arg.startswith(\"-\" if prefix == \"auto\" else prefix):\n        return None, None, arg\n\n    # fill a tuple to length of 2 with None\n    fill2_none: Callable = lambda alist: (\n        (alist[0], None) if len(alist) == 1 or not alist[1] else alist[:2]\n    )\n\n    item_nametype, item_value = fill2_none(arg.split(\"=\", 1))\n    item_name, item_type = fill2_none(item_nametype.split(\":\", 1))\n\n    # detach the value for -b1\n    if allow_attached:\n        single_prefix: str = \"-\" if prefix == \"auto\" else prefix\n        len_spref: int = len(single_prefix)\n        if (\n            item_type is None\n            and item_value is None\n            and (\n                item_name.startswith(single_prefix)\n                and item_name[len_spref : len_spref + 1] != single_prefix\n            )\n        ):\n            # Type: str, str\n            item_name, item_value = (\n                single_prefix + item_name[len_spref : len_spref + 1],\n                item_name[len_spref + 1 :],\n            )\n\n    # remove prefix in item_name\n    if prefix == \"auto\":\n        item_name_first: str = item_name.split(\".\")[0]\n        prefix = (\n            \"-\"\n            if len(item_name_first) &lt;= 2\n            else \"--\"\n            if len(item_name_first) &gt;= 4\n            else None\n        )\n\n    if prefix is not None and item_name.startswith(prefix):\n        item_name = item_name[len(prefix) :]\n    else:\n        return None, None, arg\n\n    item_type, item_subtype = parse_type(item_type)\n    item_type = f\"{item_type}:{item_subtype}\" if item_subtype else item_type\n\n    return item_name, item_type, item_value\n\n\ndef type_from_value(value: Any) -&gt; str:DOCS\n    \"\"\"Detect parameter type from a value\n\n    Args:\n        value: The value\n\n    Returns:\n        The name of the type\n\n    Raises:\n        PyParamTypeError: When we have list as subtype.\n            For example, when value is `[[1]]`\n    \"\"\"\n    typename: str = type(value).__name__\n    if typename in (\"int\", \"float\", \"str\", \"bool\"):\n        return typename\n    if isinstance(value, list):\n        if not value:\n            return \"list\"\n        type0: str = type_from_value(value[0])\n        if \"list\" in type0:\n            raise PyParamTypeError(\"Cannot have 'list' as subtype.\")\n        return (\n            f\"list:{type0}\"\n            if all(type_from_value(item) == type0 for item in value[1:])\n            else \"list\"\n        )\n    if isinstance(value, dict):\n        return \"json\"\n    if isinstance(value, Path):\n        return \"path\"\n    return \"auto\"\n\n\ndef _cast_auto(value: Any) -&gt; Any:\n    \"\"\"Cast value automatically\n\n    Args:\n        value: value to cast\n\n    Returns:\n        value casted\n    \"\"\"\n    if value in (\"True\", \"TRUE\", \"true\") or value is True:\n        return True\n    if value in (\"False\", \"FALSE\", \"false\") or value is False:\n        return False\n\n    try:\n        return int(value)\n    except (TypeError, ValueError):\n        pass\n\n    try:\n        return float(value)\n    except (TypeError, ValueError):\n        pass\n\n    try:\n        return json.loads(value)\n    except (TypeError, ValueError, json.JSONDecodeError):\n        pass\n\n    return value\n\n\ndef cast_to(value: Any, to_type: Union[str, bool]) -&gt; Any:DOCS\n    \"\"\"Cast a value to a given type\n\n    Args:\n        value: value to cast\n        to_type: type to cast\n\n    Returns:\n        casted value\n\n    Raises:\n        PyParamTypeError: if value is not able to be casted\n    \"\"\"\n    try:\n        if to_type in (\"int\", \"float\", \"str\"):\n            return getattr(builtins, to_type)(value)  # type: ignore\n        if to_type == \"bool\":\n            if value in (\"true\", \"TRUE\", \"True\", \"1\", 1, True):\n                return True\n            if value in (\"false\", \"FALSE\", \"False\", \"0\", 0, False):\n                return False\n            raise PyParamTypeError(\n                \"Expecting one of [true, TRUE, True, 1, false, FALSE, False, 0]\"\n            )\n\n        if to_type == \"json\":  # pragma: no cover\n            if isinstance(value, str):\n                return json.loads(value)\n            return json.loads(json.dumps(value))\n\n        if to_type in (\"path\", \"py\"):\n            return {\"path\": Path, \"py\": ast.literal_eval}[\n                to_type  # type: ignore\n            ](str(value))\n        if to_type in (None, \"auto\"):\n            if not isinstance(value, str):\n                return value\n            return _cast_auto(value)\n    except (\n        TypeError,\n        ValueError,\n        json.JSONDecodeError\n    ) as cast_exc:  # pragma: no cover\n        raise PyParamTypeError(\n            f\"Cannot cast {value} to {to_type}: {cast_exc}\"\n        ) from cast_exc\n    raise PyParamTypeError(f\"Cannot cast {value} to {to_type}\")\n\n\nclass RichHandler(_RichHandler):DOCS\n    \"\"\"Subclass of rich.logging.RichHandler, showing log levels as a single\n    character\"\"\"\n\n    def get_level_text(self, record: logging.LogRecord) -&gt; Text:DOCS\n        \"\"\"Get the level name from the record.\n        Args:\n            record (LogRecord): LogRecord instance.\n        Returns:\n            Text: A tuple of the style and level name.\n        \"\"\"\n        level_name = record.levelname\n        level_text = Text.styled(\n            level_name.upper() + \":\", f\"logging.level.{level_name.lower()}\"\n        )\n        return level_text\n\n\nlogger = logging.getLogger(__name__)\nlogger.addHandler(\n    RichHandler(\n        logging.INFO, console=Console(), show_time=False, show_path=False\n    )\n)\n</code></pre>"}]}